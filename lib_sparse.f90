MODULE SPARSE
  USE BASFUN
CONTAINS
!-------------------------------------------------
!*** TAKES A ONE-TO-MANY REPRESENTATION
!*** AND PROVIDES A MANY-TO-MANY
!*** REPRESENTATION CORRESPONDING TO ITS TRANSPOSE
!-------------------------------------------------
  SUBROUTINE ENLARGE(MLIS,LIS,NLIS,ILIST,JLIST,IJ)
    INTEGER,DIMENSION(:)::LIS
    INTEGER,DIMENSION(:),ALLOCATABLE::ILIST,JLIST,ILIS,JLIS,IJ
    CALL SALLOC(MLIS+1,ILIS)
    ILIS(1)=1
    DO I=2,MLIS+1
       ILIS(I)=ILIS(I-1)+1
    END DO
    CALL SALLOC(MLIS,JLIS)
    CALL NCOPY(MLIS,JLIS,LIS)
    CALL SPARSETRANSPINDEX(MLIS,NLIS,ILIS,JLIS,IJ,ILIST,JLIST)
    CALL SALLOC(0,ILIS)
    CALL SALLOC(0,JLIS)
  END SUBROUTINE ENLARGE

!----------------------------------------------------------
!*** PROVIDES AN EDGE, FACE OR VOLUME GIVEN A LIST OF NODES
!----------------------------------------------------------
  INTEGER FUNCTION IFROMNODES(NN,LN,INOPOLY,JNOPOLY,IPOLNOD,JPOLNOD)
    INTEGER,DIMENSION(*)::LN,INOPOLY,JNOPOLY,IPOLNOD,JPOLNOD
    INTEGER,DIMENSION(NN)::LP
    IFROMNODES=0
    INO=LN(1)
    DO IK=INOPOLY(INO),INOPOLY(INO+1)-1
       IFA=JNOPOLY(IK)
       DO JK=IPOLNOD(IFA),IPOLNOD(IFA+1)-1
          LNO=JPOLNOD(JK)
          LP(JK+1-IPOLNOD(IFA))=LNO
       END DO
       IF(NN.EQ.IPOLNOD(IFA+1)-IPOLNOD(IFA))THEN
          IF(IFLISCO(NN,LN,.FALSE.,LP,.FALSE.))THEN
             IFROMNODES=IFA
             EXIT
          END IF
       END IF
    END DO
  END FUNCTION IFROMNODES

!--------------------------------------------------------------
!*** FROM A GIVEN LIST, AND A SECOND ADDRESSING, MAKES A SPARSE
!*** RELATION USING THE SECOND LIST AS ROW NUMBER
!*** TRANSPOSE OF A SPARSE TENSOR PRODUCT
!
!*** EXAMPLE:
!*** LIS1 ->3 4 6 1 2 2 ! LIST OF DOFS
!*** LIS2 ->2 2 3 3 4 5 ! COLORS OF DOF
!*** LIS2T->3 3 5 2 2 2 ! LIST OF COLORS
!*** IND ->1 1 4 6 6 7 ! POINTERS TO BEGINNING OF EACH COLOR
!*** LIS ->4 5 6 1 2 3 ! POSITIONS OF EACH COLOR
!--------------------------------------------------------------
  SUBROUTINE TENSORPRODLISTS(N,LIS1,LIS2,M,IND,LIS,IJ)
    INTEGER,DIMENSION(*)::LIS1,LIS2
    INTEGER,DIMENSION(:),ALLOCATABLE::IND,LIS,LIS2T,IJ
    IF(N.EQ.0)THEN
       M=0
    ELSE
       CALL SALLOC(N,LIS2T)
       DO I=1,N
          LIS2T(I)=LIS2(LIS1(I))
       END DO
       CALL ENLARGE(N,LIS2T,M,IND,LIS,IJ)
       CALL SALLOC(0,LIS2T)
    END IF
  END SUBROUTINE TENSORPRODLISTS

!-------------------------------------
!*** DUAL LOCAL GRAPH
!*** NEIGHBORS, ETC
!*** USING A CONVENTIONAL NOMENCLATURE
!*** IEL
!-------------------------------------
  SUBROUTINE DUALLOCALGRAPH(IEL,ELNI,ELNO,NOIL,NOEL,NL,LISTA)
    INTEGER,DIMENSION(*)::ELNI,ELNO,NOIL,NOEL
    INTEGER,DIMENSION(:),ALLOCATABLE::LISTA
    NL=0
    DO J=ELNI(IEL),ELNI(IEL+1)-1
       K=ELNO(J)
       DO L=NOIL(K),NOIL(K+1)-1
          M=NOEL(L)
          IF(M.NE.IEL)THEN
             NL=NL+1
             CALL INSERT(LISTA,NL,M)
          END IF
       END DO
    END DO
    CALL PURGAR(NL,LISTA,.FALSE.)
  END SUBROUTINE DUALLOCALGRAPH

!---------------------------
!*** CONVERTS FROM ILIN/ICOL
!---------------------------
  SUBROUTINE CONVERTFROMCOO(NUM,NNZ,IPO,LIS,ILIN,ICOL,V1,V2)
    IMPLICIT REAL(8)(A-H,O-Z)
    INTEGER,DIMENSION(:),ALLOCATABLE::IPO,LIS
    INTEGER,DIMENSION(*)::ILIN,ICOL
    REAL(8),DIMENSION(*),OPTIONAL::V1,V2
    CALL SALLOC(NUM+1,IPO)
    CALL SALLOC(0,LIS)
    DO K=1,NNZ
       IPO(ILIN(K))=IPO(ILIN(K))+1
    END DO
    CALL SPALLOC1(NUM,IPO,LIS)    
    DO K=1,NNZ
       I=ILIN(K)
       J=ICOL(K)
       IAD=IPO(I)
       IF(PRESENT(V1))X=V1(K)
       IF(PRESENT(V2))V2(IAD)=X
       LIS(IAD)=J
       IPO(I)=IAD+1
    END DO
    CALL MUDLIS2(NUM,IPO)
  END SUBROUTINE CONVERTFROMCOO

!-----------------------------------
!*** CONVERSION TO ILIN/ICOL ROUTINE
!-----------------------------------
  SUBROUTINE CONVERTTOCOO(NUM,IPO,LIS,ILIN,ICOL)
    IMPLICIT REAL(8)(A-H,O-Z)
    INTEGER,DIMENSION(*)::IPO,LIS
    INTEGER,DIMENSION(:),ALLOCATABLE::ILIN,ICOL
    NNZ=IPO(NUM+1)-IPO(1)
    CALL SALLOC(NNZ,ILIN)
    CALL SALLOC(NNZ,ICOL)
    DO IR=1,NUM
       DO IZ=IPO(IR),IPO(IR+1)-1
          IC=LIS(IZ)
          ILIN(IZ)=IR
          ICOL(IZ)=IC
       END DO
    END DO
  END SUBROUTINE CONVERTTOCOO

!-----------------------------------------
!*** CHECKS IF A SPARSE RELATION IS SORTED
!-----------------------------------------
  LOGICAL FUNCTION COLSORTED(NA,IA,JA)
    INTEGER NA, IA(*), JA(*)
    DO I=1, NA
       DO J=IA(I)+1,IA(I+1)-1
          IF (JA(J-1).GE.JA(J)) THEN
             COLSORTED=.FALSE.
             RETURN
          ENDIF
       ENDDO
    ENDDO
    COLSORTED = .TRUE.
  END FUNCTION COLSORTED

!------------------------------
!*** ALLOCATION OF SPARSE STUFF
!------------------------------
  SUBROUTINE SPALLOC1(MA,IA,JA)
    INTEGER,DIMENSION(*)::IA
    INTEGER,DIMENSION(:),ALLOCATABLE::JA
    IF(MA.GT.0)THEN
       IF(IA(MA+1).LE.0)THEN
          CALL MUDLIS(MA,IA)
       END IF
       ITEMP=IA(MA+1)-1
       CALL SALLOC(ITEMP,JA)
    END IF
  END SUBROUTINE SPALLOC1

!------------------------------
!*** ALLOCATION OF SPARSE STUFF
!*** WITH VALUES  
!------------------------------
  SUBROUTINE SPALLOC2(MA,IA,VA)
    INTEGER,DIMENSION(*)::IA
    REAL(8),DIMENSION(:),ALLOCATABLE::VA
    IF(MA.GT.0)THEN
       IF(IA(MA+1).LE.0)THEN
          CALL MUDLIS(MA,IA)
       END IF
       ITEMP=IA(MA+1)-1
       CALL SALLOC(ITEMP,VA)
    END IF
  END SUBROUTINE SPALLOC2

!--------------
!*** FROM DENSE
!--------------
  SUBROUTINE FROMDENSE(NA,IA,JA,VA,NR,NC,A)
    IMPLICIT REAL(8)(A-H,O-Z)
    INTEGER,DIMENSION(:),ALLOCATABLE::IA,JA
    REAL(8),DIMENSION(:),ALLOCATABLE::VA
    REAL(8),DIMENSION(NR,*)::A
    NA=NR
    SMALL=TINY(1.0D00)
    NEXT=1
    CALL SALLOC(NA+1,IA)
    IA(1)=1
    DO IR=1,NR
       DO IC=1,NC
          IF(ABS(A(IR,IC)).GT.SMALL)NEXT=NEXT+1
          IA(IR+1)=NEXT
       END DO
    END DO
    NEXT=1
    CALL SALLOC(IA(NA+1)-IA(1),JA)
    CALL SALLOC(IA(NA+1)-IA(1),VA)
    DO IR=1,NR
       DO IC=1,NC
          IF(ABS(A(IR,IC)).GT.SMALL)THEN
             JA(NEXT)=IC
             VA(NEXT)=A(IR,IC)
             NEXT=NEXT+1
          END IF
       END DO
    END DO
  END SUBROUTINE FROMDENSE

!------------
!*** TO DENSE
!------------  
  SUBROUTINE TODENSE(NA,IA,JA,VA,NR,NC,A)
    IMPLICIT REAL(8)(A-H,O-Z)
    INTEGER,DIMENSION(*)::IA,JA
    REAL(8),DIMENSION(*)::VA
    REAL(8),DIMENSION(:,:),ALLOCATABLE::A
    NR=NA
    NC=NUMINJ(NA,IA,JA)
    CALL SALLOC(NR,NC,A)
    DO I=1,NA
       DO J=IA(I),IA(I+1)-1
          A(I,JA(J))=VA(J)
       END DO
    END DO
  END SUBROUTINE TODENSE

!---------------------------------------------------
!*** BINARY SEARCH: GETS A GIVEN ELEMENT WHEN IA, JA
!*** IS SORTED
!---------------------------------------------------
  INTEGER FUNCTION GETSPARSELMSORT(RA,CA,IA,JA)
    INTEGER::RA,CA
    INTEGER,DIMENSION(*)::IA,JA
    IADD=0
    IBEG=IA(RA)
    IEND=IA(RA+1)-1
10  CONTINUE
    IMID=(IBEG+IEND)/2
    IF(JA(IMID).EQ.CA)THEN
       IADD=IMID
    ELSEIF(IBEG.GE.IEND)THEN
       IADD=0
    ELSE
       IF(JA(IMID).GT.CA)THEN
          IEND=IMID-1
       ELSE
          IBEG=IMID+1
       END IF
       GOTO 10
    END IF
    GETSPARSELMSORT=IADD
  END FUNCTION GETSPARSELMSORT

!----------------------------------
!*** CALCULATES IC FOR A SPARSE SUM
!----------------------------------
  SUBROUTINE APLUSBFIRSTPART(NRA,IA,JA,IB,JB,IC)
    IMPLICIT REAL(8)(A-H,O-Z)
    INTEGER::RA,CA,CB
    INTEGER,DIMENSION(*)::IA,IB,JA,JB
    INTEGER,DIMENSION(:),ALLOCATABLE::IC,IW
    CALL SALLOC(NRA+1,IC)
    CALL SALLOC(NUMINJ(NRA,IA,JA),IW)
    LEN=0
    IC(1)=1
    DO RA=1,NRA
       DO KA=IA(RA),IA(RA+1)-1
          LEN=LEN+1
          CA=JA(KA)
          IW(CA)=LEN
       END DO
       DO KB=IB(RA),IB(RA+1)-1
          CB=JB(KB)
          IF(IW(CB).EQ.0)THEN
             LEN=LEN+1
             IW(CB)=LEN
          END IF
       END DO
       DO KA=IA(RA),IA(RA+1)-1
          IW(JA(KA))=0
       END DO
       DO KB=IB(RA),IB(RA+1)-1
          IW(JB(KB))=0
       END DO
       IC(RA+1)=LEN+1
    END DO
    CALL SALLOC(0,IW)
  END SUBROUTINE APLUSBFIRSTPART

!--------------------------------------------
!*** AFTER IC, CALCULATES JC FOR A SPARSE SUM
!--------------------------------------------
  SUBROUTINE APLUSBINTERMEDIATEPART(NRA,IA,JA,IB,JB,IC,JC)
    IMPLICIT REAL(8)(A-H,O-Z)
    INTEGER::RA,CA,CB
    INTEGER,DIMENSION(*)::IA,IB,IC,JA,JB
    INTEGER,DIMENSION(:),ALLOCATABLE::JC,IW
    ITEMP=IC(NRA+1)-1
    CALL SALLOC(ITEMP,JC)
    CALL SALLOC(NUMINJ(NRA,IA,JA),IW)
    LEN=0
    IC(1)=1
    DO RA=1,NRA
       DO KA=IA(RA),IA(RA+1)-1
          CA=JA(KA)
          LEN=LEN+1
          JC(LEN)=CA
          IW(CA)=LEN
       END DO
       DO K=IB(RA),IB(RA+1)-1
          CB=JB(K)
          IF(IW(CB).EQ.0)THEN
             LEN=LEN+1
             JC(LEN)=CB
             IW(CB)=LEN
          END IF
       END DO
       DO KA=IA(RA),IA(RA+1)-1
          IW(JA(KA))=0
       END DO
       DO KB=IB(RA),IB(RA+1)-1
          IW(JB(KB))=0
       END DO
       IC(RA+1)=LEN+1
    END DO
    CALL SALLOC(0,IW)
  END SUBROUTINE APLUSBINTERMEDIATEPART

!---------------------------------------------------
!*** AFTER IC AND JC, CALCULATES VC FOR A SPARSE SUM
!---------------------------------------------------
  SUBROUTINE APLUSBSECONDPART(NRA,ALPHA_A,IA,JA,VA,ALPHA_B,IB,JB,VB,IC,JC,VC)
    IMPLICIT REAL(8)(A-H,O-Z)
    INTEGER::RA,CA,CB
    INTEGER,DIMENSION(*)::IA,IB,IC,JA,JB,JC
    REAL(8),DIMENSION(*)::VA,VB
    INTEGER,DIMENSION(:),ALLOCATABLE::IW
    REAL(8),DIMENSION(:),ALLOCATABLE::VC
    ITEMP=IC(NRA+1)-1
    CALL SALLOC(ITEMP,VC)
    CALL SALLOC(NUMINJ(NRA,IA,JA),IW)
    LEN=0
    IC(1)=1
    DO RA=1,NRA
       DO KA=IA(RA),IA(RA+1)-1
          LEN=LEN+1
          CA=JA(KA)
          VC(LEN)=ALPHA_A*VA(KA)
          IW(CA)=LEN
       END DO
       DO K=IB(RA),IB(RA+1)-1
          CB=JB(K)
          IF(IW(CB).EQ.0)THEN
             LEN=LEN+1
             VC(LEN)=ALPHA_B*VB(K)
             IW(CB)=LEN
          ELSE
             VC(IW(CB))=VC(IW(CB))+ALPHA_B*VB(JP)
          END IF
       END DO
       DO KA=IA(RA),IA(RA+1)-1
          IW(JA(KA))=0
       END DO
       DO KB=IB(RA),IB(RA+1)-1
          IW(JB(KB))=0
       END DO
       IC(RA+1)=LEN+1
    END DO
    CALL SALLOC(0,IW)
  END SUBROUTINE APLUSBSECONDPART

!--------------
!*** SPARSE SUM
!--------------
  SUBROUTINE APLUSB(NRA,ALPHA_A,IA,JA,VA,ALPHA_B,IB,JB,VB,IC,JC,VC)
    IMPLICIT REAL(8)(A-H,O-Z)
    INTEGER,DIMENSION(*)::IA,IB,JA,JB
    REAL(8),DIMENSION(*)::VA,VB
    INTEGER,DIMENSION(:),ALLOCATABLE::IC,JC
    REAL(8),DIMENSION(:),ALLOCATABLE::VC
    CALL APLUSBFIRSTPART(NRA,IA,JA,IB,JB,IC)
    CALL APLUSBINTERMEDIATEPART(NRA,IA,JA,IB,JB,IC,JC)
    CALL APLUSBSECONDPART(NRA,ALPHA_A,IA,JA,VA,ALPHA_B,IB,JB,VB,IC,JC,VC)
  END SUBROUTINE APLUSB

!------------------
!*** SPARSE ATIMESV
!*** W=A.V
!------------------
  SUBROUTINE ATIMESV(NRA,IA,JA,VA,V,W)
    IMPLICIT REAL(8) (A-H,O-Z)
    INTEGER::RA
    INTEGER,DIMENSION(*)::IA,JA
    REAL(8),DIMENSION(*)::VA
    REAL(8),DIMENSION(*)::V,W
!$OMP PARALLEL DO
    DO RA=1,NRA
       T=0.0D00
       DO KA=IA(RA),IA(RA+1)-1
          T=T+VA(KA)*V(JA(KA))
       END DO
       W(RA)=T
    END DO
!$OMP END PARALLEL DO
  END SUBROUTINE ATIMESV

!---------------------------------
!*** SPARSE ATTIMESV (A TRANSPOSE)
!*** W=AT.V
!---------------------------------
  SUBROUTINE ATTIMESV(NRA,IA,JA,VA,V,W)
    IMPLICIT REAL(8) (A-H,O-Z)
    INTEGER::RA
    INTEGER,DIMENSION(*)::IA,JA
    REAL(8),DIMENSION(*)::VA,V,W
    CALL PCONSR(NUMINJ(NRA,IA,JA),W)
!$OMP PARALLEL DO
    DO RA=1,NRA
       DO KA=IA(RA),IA(RA+1)-1
          W(JA(KA))=W(JA(KA))+V(RA)*VA(KA)
       END DO
    END DO
!$OMP END PARALLEL DO
  END SUBROUTINE ATTIMESV

!------------------------------------------
!*** DETERMINES POSITIONS OF COMMON VALUES
!*** IN A AND B
!*** RETURN INA AND INB IN REVERSE ORDER
!*** NAB IS THE TOTAL NUMBER OF HITS
!*** A AND B MUST BE IN INCREASING ORDER
!------------------------------------------
  SUBROUTINE MUTUALLOCATIONS(NA,NB,A,B,NAB,INA,INB)
    INTEGER::NA,NB,NAB
    INTEGER,DIMENSION(*)::A,B,INA,INB
    NAT=NA
    NBT=NB
    NAB=0
    DO WHILE(NA.GT.0.AND.NB.GT.0)
       IF(A(NA).EQ.B(NB))THEN
          NAB=NAB+1
          INA(NAB)=NA
          INB(NAB)=NB
       END IF
       IF(A(NA).LE.B(NB))THEN
          NB=NB-1
       ELSE
          NA=NA-1
       END IF
    END DO
    NA=NAT
    NB=NBT
  END SUBROUTINE MUTUALLOCATIONS

!----------------------------------------
!*** DEPTH FIRST SEARCH FOR A GIVEN ROW I
!*** MARKS ROWS IN MK
!----------------------------------------
  SUBROUTINE DEPTHFIRSTSEARCH(NRA,IA,JA,I,NM,MK)
    INTEGER::RA,CA
    INTEGER,DIMENSION(:),ALLOCATABLE::STACK
    INTEGER,DIMENSION(*)::MK
    INTEGER,DIMENSION(*)::IA,JA
    RA=I
    ALLOCATE(STACK(IA(NRA+1)-1))
    NSTACK=1
    STACK(NSTACK)=RA
    DO
       IF(NSTACK.EQ.0)EXIT
       RA=STACK(NSTACK)
       NSTACK=NSTACK-1
       IF(MK(RA).EQ.0)THEN
          NM=NM+1
          MK(RA)=1
          DO KA=IA(RA),IA(RA+1)-1
             CA=JA(KA)
             NSTACK=NSTACK+1
             STACK(NSTACK)=CA
          END DO
       END IF
    END DO
    DEALLOCATE(STACK)
  END SUBROUTINE DEPTHFIRSTSEARCH

!-----------------------------
!*** SYMBOLIC LOWER TRIANGULAR
!*** SOLUTION OF L.X=B
!-----------------------------
  SUBROUTINE SPARSESPARSELXBSYMB(NCL,ILT,JLT,IXT,JXT,NCB,IBT,JBT)
    INTEGER::CL,RB,CB,NM
    INTEGER,DIMENSION(*)::IBT,JBT
    INTEGER,DIMENSION(:),ALLOCATABLE::ILT,JLT,IXT,JXT,MK
    NCX=NCL
    CALL SALLOC(NCL,MK)
    CALL SALLOC(NCX+1,IXT)
    DO CB=1,NCB
       MK=0
       NM=0
       DO KB=IBT(CB),IBT(CB+1)-1
          RB=JBT(KB)
          CL=RB
          CALL DEPTHFIRSTSEARCH(NCL,ILT,JLT,CL,NM,MK)
       END DO
       IXT(CB)=NM+1
    END DO
    CALL SPALLOC1(NCX,IXT,JXT)      
    DO CB=1,NCB
       MK=0
       NM=0
       DO KB=IBT(CB),IBT(CB+1)-1
          RB=JBT(KB)
          CL=RB
          CALL DEPTHFIRSTSEARCH(NCL,ILT,JLT,CL,NM,MK)
       END DO
       L=0
       DO CL=1,NCL
          IF(MK(CL).EQ.1)THEN
             L=L+1
             JXT(IXT(CB)-1+L)=CL
          END IF
       END DO
       JXT(IXT(CB+1)-1)=CB+NCL
    END DO
    CALL SALLOC(0,MK)
  END SUBROUTINE SPARSESPARSELXBSYMB

!-----------------------------------------------------
!*** ENLARGED (WITH IDENTITY) NUMERIC LOWER TRIANGULAR
!*** SOLUTION OF L.X=B
!-----------------------------------------------------
  SUBROUTINE SPARSESPARSELXBNUM(NRL,ILT,JLT,VLT,IXT,JXT,VXT,NCB,IBT,JBT,VBT)
    INTEGER::RL,CL
    INTEGER,DIMENSION(*)::ILT,JLT
    REAL(8),DIMENSION(*)::VLT
    INTEGER::RX,CX
    INTEGER,DIMENSION(*)::IXT,JXT
    REAL(8),DIMENSION(:),ALLOCATABLE::VXT
    INTEGER::RB,CB
    INTEGER,DIMENSION(*)::IBT,JBT
    REAL(8),DIMENSION(*)::VBT
    INTEGER,DIMENSION(:),ALLOCATABLE::PLACE
    NRX=NRL
    NCX=NCB
    NRB=NRL
    CALL SALLOC(NRX,PLACE)
    CALL SALLOC(IXT(NCX+1)-1,VXT)
    DO CB=1,NCB
       CX=CB
       DO K=IXT(CX),IXT(CX+1)-2
          RX=JXT(K)
          PLACE(RX)=K
       END DO
       DO K=IBT(CB),IBT(CB+1)-1
          RB=JBT(K)
          L=PLACE(RB)
          VXT(L)=VBT(K)/VLT(ILT(RB))
       END DO
       CX=CB
       DO KX=IXT(CX),IXT(CX+1)-2
          RX=JXT(KX)
          CL=RX
          DO KL=ILT(CL),ILT(CL+1)-1
             RL=JLT(KL)
             IF(RX.GE.RL)CYCLE
             L=PLACE(RL)
             VXT(L)=VXT(L)-VXT(KX)*VLT(KL)/VLT(ILT(RL))
          END DO
       END DO
       VXT(IXT(CX+1)-1)=-1.0D00 !*** SETS TO -1
    END DO
    CALL SALLOC(0,PLACE)
  END SUBROUTINE SPARSESPARSELXBNUM

!------------------------------------------
!*** DETERMINES THE STRUCTURE OF KR=Z^T.K.Z
!------------------------------------------
  SUBROUTINE SPARSEZKZSYMB(NRZ,NCZ,IZ,JZ,IZT,JZT,IJZT,IK,JK,IKR,JKR)
    INTEGER::RZ,CZ,RZT,CZT,RK,CK,CKR,RKR
    INTEGER,DIMENSION(:),ALLOCATABLE::IKR,JKR
    INTEGER,DIMENSION(*)::IZT,JZT,IK,JK
    INTEGER,DIMENSION(:),ALLOCATABLE::IZ,JZ,IJZT
    INTEGER,DIMENSION(:),ALLOCATABLE::IW
    CALL SPARSETRANSPINDEX(NCZ,NRZ,IZT,JZT,IJZT,IZ,JZ)
    CALL SALLOC(NCZ+1,IKR)
    CALL SALLOC(NCZ,IW)
    NRKR=NCZ
    DO RKR=1,NRKR
       IW=0
       LEN=0
       DO K1=IZT(RKR),IZT(RKR+1)-1
          RZ=JZT(K1)
          DO K2=IK(RZ),IK(RZ+1)-1
             CK=JK(K2)
             DO K3=IZ(CK),IZ(CK+1)-1
                CZ=JZ(K3)
                IF(IW(CZ).EQ.0)THEN
                   LEN=LEN+1
                   IW(CZ)=1
                END IF
             END DO
          END DO
       END DO
       IKR(RKR)=LEN
    END DO
    CALL MUDLIS(NRKR,IKR)
    CALL SALLOC(IKR(NRKR+1)-1,JKR)
    LEN=0
    DO RKR=1,NRKR
       IW=0
       DO K1=IZT(RKR),IZT(RKR+1)-1
          RZ=JZT(K1)
          DO K2=IK(RZ),IK(RZ+1)-1
             CK=JK(K2)
             DO K3=IZ(CK),IZ(CK+1)-1
                CZ=JZ(K3)
                IF(IW(CZ).EQ.0)THEN
                   LEN=LEN+1
                   JKR(LEN)=CZ
                   IW(CZ)=LEN
                END IF
             END DO
          END DO
       END DO
    END DO
    CALL SALLOC(0,IW)
  END SUBROUTINE SPARSEZKZSYMB

!-------------------------
!*** DETERMINES ZR=Z^T.K.Z
!*** GIVEN THE INDICES
!-------------------------
  SUBROUTINE SPARSEZKZNUM(NRZ,NCZ,IZ,JZ,IZT,JZT,VZT,IJZT,IK,JK,VK,IKR,JKR,VKR)
    IMPLICIT REAL(8)(A-H,O-Z)
    REAL(8),DIMENSION(*)::VZT,VK
    INTEGER,DIMENSION(:),ALLOCATABLE::IW
    REAL(8),DIMENSION(:),ALLOCATABLE::VKR
    INTEGER,DIMENSION(*)::IKR,JKR
    INTEGER,DIMENSION(*)::IZ,JZ,IK,JK
    INTEGER,DIMENSION(*)::IZT,JZT,IJZT
    CALL SALLOC(NCZ,IW)
    CALL SALLOC(IKR(NCZ+1)-1,VKR)
    LEN=0
    NRKR=NCZ
    DO RKR=1,NRKR
       IW=0
       DO K1=IZT(RKR),IZT(RKR+1)-1
          RZ=JZT(K1)
          VALZT=VZT(K1)
          DO K2=IK(RZ),IK(RZ+1)-1
             CK=JK(K2)
             VALK=VK(K2)
             DO K3=IZ(CK),IZ(CK+1)-1
                CZ=JZ(K3)
                VALZ=VZT(IJZT(K3)+IZT(CZ)-1)
                IF(IW(CZ).EQ.0)THEN
                   LEN=LEN+1
                   VKR(LEN)=VKR(LEN)+VALZT*VALK*VALZ
                   IW(CZ)=LEN
                ELSE
                   LG=IW(CZ)
                   VKR(LG)=VKR(LG)+VALZT*VALK*VALZ
                END IF
             END DO
          END DO
       END DO
    END DO
    CALL SALLOC(0,IW)
  END SUBROUTINE SPARSEZKZNUM

!--------------------------------------------------------
!*** SOLUTION OF A CONSTRAINED SYSTEM
!*** USING LAGRANGE MULTIPLERS
!*** PRE-ASSIGNED PIVOTS ARE FIRST ACTIVE COLUMNS IN GRAD
!--------------------------------------------------------  
  SUBROUTINE SOLVECONSTRAINEDSPARSE(MGRAD,MJAC,RES,G,IJAC,JJAC,VJAC,IGRAD,JGRAD,VGRAD,IGRAD2,JGRAD2,VGRAD2,LAGRANGE,SOLUTION)
    IMPLICIT REAL(8)(A-H,O-Z)
    REAL(8),DIMENSION(*)::RES,G,LAGRANGE,SOLUTION
    INTEGER,DIMENSION(*)::IJAC,JJAC,IGRAD,JGRAD
    INTEGER,DIMENSION(:),ALLOCATABLE::IGRAD2,JGRAD2
    REAL(8),DIMENSION(:),ALLOCATABLE::VGRADT,Q2
    REAL(8),DIMENSION(:,:),ALLOCATABLE::REDUCED
    REAL(8),DIMENSION(*)::VJAC,VGRAD
    REAL(8),DIMENSION(:),ALLOCATABLE::VGRAD2
    INTEGER,DIMENSION(:),ALLOCATABLE::IGRADNEW,JGRADNEW,IGRADT,JGRADT,IZT,JZT,IZ,JZ,IJZT
    INTEGER,DIMENSION(:),ALLOCATABLE::ISTIFF,JSTIFF,INEWSTIFF,JNEWSTIFF,IREDSTIFF,JREDSTIFF
    INTEGER,DIMENSION(:),ALLOCATABLE::NEWOLD
    REAL(8),DIMENSION(:),ALLOCATABLE::VSTIFF,VGRADNEW,VNEWSTIFF,VZT,F2,F2R,VREDSTIFF,F1,Q1
    IF(ALLOCATED(IGRAD2))THEN
!------------------------------
!*** JAC-GRAD2 AND OBTAIN STIFF
!------------------------------
       CALL APLUSB(MJAC,1.0D00,IJAC,JJAC,VJAC,-1.0D00,IGRAD2,JGRAD2,VGRAD2,ISTIFF,JSTIFF,VSTIFF)
    ELSE
       CALL SALLOC(MJAC+1,ISTIFF)
       CALL SALLOC(IJAC(MJAC+1)-1,JSTIFF)
       CALL SALLOC(IJAC(MJAC+1)-1,VSTIFF)
       ISTIFF=IJAC(1:MJAC+1)
       JSTIFF=JJAC(1:IJAC(MJAC+1)-1)
       VSTIFF=VJAC(1:IJAC(MJAC+1)-1)
    END IF
!---------------
!*** SWAPS VGRAD
!---------------
    DO I=1,IGRAD(MGRAD+1)-1
       VGRAD(I)=-VGRAD(I)
    END DO
!-------------------------------------------------------------------------------
!*** TREATS THE CONSTRAINT GRADIENT
!*** L1 AND B2 ARE NOW IN GRADNEW (L1 IN COLUMNS 1:MGRAD AND B2 IN MGRAD+1:MJAC)
!-------------------------------------------------------------------------------
    CALL TREATCONSTRAINTMATRIX(MGRAD,MJAC,IGRAD,JGRAD,VGRAD,NEWOLD,IGRADNEW,JGRADNEW,VGRADNEW)
!------------------------------
!*** NOW PERMUTS DOFS IN RES, G
!------------------------------
    CALL RCHANGEPERMUTATION(MJAC,NEWOLD,RES,2)
    CALL RCHANGEPERMUTATION(MJAC,NEWOLD,G,2)
!-------------------------------------
!*** NOW SETS NON-SLAVE DOFS IN G TO 0
!-------------------------------------
    DO I=MGRAD+1,MJAC
       G(I)=0.0D00
    END DO
!------------------------------
!*** PERMUTES DOFS IN STIFFNESS
!------------------------------
    CALL SALLOC(MJAC+1,INEWSTIFF)
    CALL SALLOC(IJAC(MJAC+1)-1,JNEWSTIFF)
    CALL SALLOC(IJAC(MJAC+1)-1,VNEWSTIFF)
    CALL ROWCOLPERM(MJAC,ISTIFF,JSTIFF,VSTIFF,INEWSTIFF,JNEWSTIFF,VNEWSTIFF,NEWOLD)
!---------------------------------
!*** STIFFNESS IS NOW (V)STIFFNESS
!---------------------------------
!----------------------------------------
!*** NOW TRANSPOSES GRADNEW AND GET GRADT
!----------------------------------------
    CALL SPARSETRANSP(MGRAD,MJAC,IGRADNEW,JGRADNEW,VGRADNEW,IGRADT,JGRADT,VGRADT)
!--------------------------
!*** NOW ONLY GRADT IS USED
!*** OTHERS ARE DISCARDED
!--------------------------
!---------------------------------------
!*** SOLVES THE TRIANGULAR SYSTEM FOR ZT
!*** AND INSERTS THE IDENTITY IN -Z
!---------------------------------------
    CALL SPARSESPARSELXBSYMB(MGRAD,IGRADT,JGRADT,IZT,JZT,MJAC-MGRAD,IGRADT(MGRAD+1),JGRADT)
    CALL SPARSESPARSELXBNUM(MGRAD,IGRADT,JGRADT,VGRADT,IZT,JZT,VZT,MJAC-MGRAD,IGRADT(MGRAD+1),JGRADT,VGRADT)
!-------------
!*** SWAPS VZT
!-------------
    VZT=-VZT
!--------------
!*** Q1=L1^-1.G
!--------------
    CALL SALLOC(MJAC,Q1)
    CALL SPARSEDENSELXBCSC(MGRAD,IGRADT,JGRADT,VGRADT,Q1,G)
!-------------
!*** F2=F-K.Q1
!-------------
    CALL SALLOC(MJAC,F2)
    CALL ATIMESV(MJAC,INEWSTIFF,JNEWSTIFF,VNEWSTIFF,Q1,F2)
    DO I=1,MJAC
       F2(I)=-RES(I)-F2(I)
    END DO
!-------
!*** F2R
!-------
    CALL SALLOC(MJAC-MGRAD,F2R)
    CALL ATIMESV(MJAC-MGRAD,IZT,JZT,VZT,F2,F2R)
!-----------------------------------------
!*** DETERMINES REDUCED STIFFNESS REDSTIFF
!-----------------------------------------
    CALL SPARSEZKZSYMB(MJAC,MJAC-MGRAD,IZ,JZ,IZT,JZT,IJZT,INEWSTIFF,JNEWSTIFF,IREDSTIFF,JREDSTIFF)
    CALL SPARSEZKZNUM(MJAC,MJAC-MGRAD,IZ,JZ,IZT,JZT,VZT,IJZT,INEWSTIFF,JNEWSTIFF,VNEWSTIFF,IREDSTIFF,JREDSTIFF,VREDSTIFF)
!-----------------------------
!*** SOLVES THE REDUCED SYSTEM
!-----------------------------
    CALL SALLOC(MJAC-MGRAD,Q2)
    CALL ITERSOLUC(MJAC-MGRAD,IREDSTIFF,JREDSTIFF,VREDSTIFF,Q2,F2R)
!---------------------------
!*** OBTAINS SOLUTION
!*** BY A LINEAR COMBINATION
!---------------------------
    CALL ATTIMESV(MJAC-MGRAD,IZT,JZT,VZT,Q2,SOLUTION)
    DO I=1,MJAC
       SOLUTION(I)=SOLUTION(I)+Q1(I)
    END DO
!--------------------------------
!*** OBTAINS LAGRANGE MULTIPLIERS
!--------------------------------
    CALL SALLOC(MJAC,F1)
    CALL ATIMESV(MJAC,INEWSTIFF,JNEWSTIFF,VNEWSTIFF,SOLUTION,F1)
    DO I=1,MJAC
       F1(I)=-RES(I)-F1(I)
    END DO
    CALL SPARSEDENSEUXBCSR(MGRAD,IGRADT,JGRADT,VGRADT,LAGRANGE,F1)
    DO I=MGRAD+1,MJAC
       LAGRANGE(I)=0.0D00
    END DO
!---------------------------------------------
!*** PERMUTS SOLUTION AND LAGRANGE MULTIPLIERS
!---------------------------------------------
    CALL RCHANGEPERMUTATION(MJAC,NEWOLD,RES,1)
    CALL RCHANGEPERMUTATION(MJAC,NEWOLD,SOLUTION,1)
    CALL RCHANGEPERMUTATION(MJAC,NEWOLD,LAGRANGE,1)
  END SUBROUTINE SOLVECONSTRAINEDSPARSE

!---------------------------------------------
!*** DEALS WITH THE CONSTRAINT GRADIENT MATRIX
!*** DOF PERMUTATION AND 
!---------------------------------------------
  SUBROUTINE TREATCONSTRAINTMATRIX(MGRAD,MJAC,IGRAD,JGRAD,VGRAD,NEWOLD,IGRADNEW,JGRADNEW,VGRADNEW)
    LOGICAL::ACYCLIC
    INTEGER::RGRAD,CGRAD
    INTEGER,DIMENSION(:),ALLOCATABLE::NEWOLD
    INTEGER,DIMENSION(*)::IGRAD,JGRAD
    REAL(8),DIMENSION(*)::VGRAD
    INTEGER,DIMENSION(:),ALLOCATABLE::TOPD,IGRADNEW,JGRADNEW,ITOPD
    REAL(8),DIMENSION(:),ALLOCATABLE::VGRADNEW
    CALL SALLOC(MJAC,NEWOLD)
    CALL SALLOC(MJAC,TOPD)
    CALL SALLOC(MJAC,ITOPD)
!*** CHECK FOR PIVOT REPETITIONS
    DO RGRAD=1,MGRAD
       CGRAD=JGRAD(IGRAD(RGRAD))
       IF(TOPD(CGRAD).EQ.1)THEN
          WRITE(*,*)"REPEATED SLAVE"
          STOP
       END IF
       TOPD(CGRAD)=1
    END DO
!*** FINDS INITIAL PIVOTS
    DO RGRAD=1,MJAC
       NEWOLD(RGRAD)=0
    END DO
    DO RGRAD=1,MGRAD
       CGRAD=JGRAD(IGRAD(RGRAD))
       NEWOLD(CGRAD)=RGRAD
    END DO
    NK=0
    DO CGRAD=1,MJAC
       IF(NEWOLD(CGRAD).EQ.0)THEN
          NK=NK+1
          NEWOLD(CGRAD)=MGRAD+NK
       END IF
    END DO
!*** COLUMN PERMUTATION
    CALL COLPERM(MGRAD,IGRAD,JGRAD,VGRAD,IGRAD,JGRAD,VGRAD,NEWOLD)
!*** NOW TOPOLOGICALLY ORDERS THE CONSTRAINTS
    CALL DOFTOPRECTANGLE(MGRAD,MJAC,IGRAD,JGRAD,ACYCLIC,TOPD)
    WRITE(*,*)"ACYCLIC",ACYCLIC
    DO I=MGRAD+1,MJAC
       TOPD(I)=I
    END DO
!*** TOPD(NEW)=OLD
!*** NOW PERMUTS ROWS IGRAD/JGRAD
    CALL SALLOC(MGRAD+1,IGRADNEW)
    CALL SALLOC(IGRAD(MGRAD+1)-1,JGRADNEW)
    CALL SALLOC(IGRAD(MGRAD+1)-1,VGRADNEW)
    DO I=1,MJAC
       ITOPD(TOPD(I))=I
    END DO
    CALL ROWCOLPERM(MGRAD,IGRAD,JGRAD,VGRAD,IGRADNEW,JGRADNEW,VGRADNEW,ITOPD)
!*** RETURN FULL PERMUTATIONS TO CALLER
    DO I=1,MJAC
       NEWOLD(I)=ITOPD(NEWOLD(I))
    END DO
  END SUBROUTINE TREATCONSTRAINTMATRIX

!--------------------------------------------------
!*** TOPOLOGICAL ORDERING OF ROWS/COLUMNS IN IA,JA
!*** WITH A BEING RECTANGULAR AND PERHAPS INCLUDING
!*** SELF EDGES
!--------------------------------------------------
  SUBROUTINE DOFTOPRECTANGLE(NRA,MCA,IA,JA,ACYCLIC,INCREASINGORDER)
    INTEGER::RA
    INTEGER,DIMENSION(*)::IA,JA
    INTEGER,DIMENSION(:),ALLOCATABLE::IND,L,INCREASINGORDER
    LOGICAL::ACYCLIC
    CALL SALLOC(NRA,IND)
    CALL SALLOC(NRA,L)
    M=1
    DO RA=1,NRA
       DO KA=IA(RA),IA(RA+1)-1
          IF(JA(KA).NE.RA.AND.JA(KA).LE.NRA)IND(JA(KA))=IND(JA(KA))+1
       END DO
    END DO
    IK=0
    DO RA=1,NRA
       IF(IND(RA).EQ.0)THEN
          IK=IK+1
          L(NRA+1-IK)=RA
       END IF
    END DO
    MK=NRA
    CALL SALLOC(MCA,INCREASINGORDER)
    DO WHILE(IK.NE.0)
       RA=L(MK)
       MK=MK-1
       IK=IK-1
       INCREASINGORDER(M)=RA
       M=M+1
       DO J=IA(RA),IA(RA+1)-1
          CA=JA(J)
          IF(CA.NE.RA)THEN
             IF(CA.LE.NRA)THEN
                IND(CA)=IND(CA)-1
                IF(IND(CA).EQ.0)THEN
                   IK=IK+1
                   L(MK+1-IK)=CA
                END IF
             END IF
          END IF
       END DO
    END DO
    IF(M.EQ.NRA+1)THEN
       ACYCLIC=.TRUE.
    ELSE
       ACYCLIC=.FALSE.
    END IF
    DO RA=1,NRA/2
       I1=INCREASINGORDER(NRA+1-RA)
       INCREASINGORDER(NRA+1-RA)=INCREASINGORDER(RA)
       INCREASINGORDER(RA)=I1
    END DO
    DEALLOCATE(IND,L)
  END SUBROUTINE DOFTOPRECTANGLE

!-------------------------
!*** SPARSE MULTIPLICATION
!*** CALCULATION OF IC
!-------------------------
  SUBROUTINE ATIMESBFIRSTPART(NA,IA,JA,NB,IB,JB,NC,IC)
    INTEGER::RA,CA,RB,CB
    INTEGER,DIMENSION(*)::IA,JA,IB,JB
    INTEGER,DIMENSION(:),ALLOCATABLE::IW,IC
    NCB=NUMINJ(NB,IB,JB)
    CALL SALLOC(NCB,IW)
    NC=NA
    CALL SALLOC(NC+1,IC)
    DO RA=1,NA
       LDG=0
       LLAST=-1
       DO KA=IA(RA),IA(RA+1)-1
          CA=JA(KA)
          DO KB=IB(CA),IB(CA+1)-1
             CB=JB(KB)
             IF(IW(CB).EQ.0)THEN
                LDG=LDG+1
                IW(CB)=LLAST
                LLAST=CB
             END IF
          END DO
       END DO
       IC(RA)=LDG
       DO K=1,LDG
          KA=IW(LLAST)
          IW(LLAST)=0
          LLAST=KA
       END DO
    END DO
    CALL MUDLIS(NC,IC)
    CALL SALLOC(0,IW)
  END SUBROUTINE ATIMESBFIRSTPART

!-------------------------
!*** SPARSE MULTIPLICATION
!*** CALCULATION OF JC 
!-------------------------
  SUBROUTINE ATIMESBINTERMEDIATEPART(NA,IA,JA,NB,IB,JB,NC,IC,JC)
    IMPLICIT REAL(8) (A-H,O-Z)
    LOGICAL::SYMB
    INTEGER::IRA,ICA,LEN
    INTEGER,DIMENSION(*)::IA,JA,IB,JB,IC
    INTEGER,DIMENSION(:),ALLOCATABLE::JC,IW
    ITEMP=IC(NC+1)-1
    CALL SALLOC(ITEMP,JC)
    NCB=NUMINJ(NB,IB,JB)
    CALL SALLOC(NCB,IW)
    LEN=0
    DO IRA=1,NA
       INI=IA(IRA)
       IFI=IA(IRA+1)-1
       DO IZA=INI,IFI
          ICA=JA(IZA)
          JNI=IB(ICA)
          JFI=IB(ICA+1)-1
          DO IZB=JNI,JFI
             ICB=JB(IZB)
             IP=IW(ICB)
             IF(IP.EQ.0)THEN
                LEN=LEN+1
                JC(LEN)=ICB
                IW(ICB)=LEN
             END IF
          END DO
       END DO
       DO IZC=IC(IRA),LEN
          IW(JC(IZC))=0
       END DO
    END DO
    CALL SALLOC(0,IW)
  END SUBROUTINE ATIMESBINTERMEDIATEPART

!-------------------------
!*** SPARSE MULTIPLICATION
!*** CALCULATION OF VC 
!-------------------------
  SUBROUTINE ATIMESBSECONDPART(NA,IA,JA,VA,NB,IB,JB,VB,NC,IC,JC,VC)
    IMPLICIT REAL(8) (A-H,O-Z)
    LOGICAL::SYMB
    INTEGER::IRA,ICA,LEN
    REAL(8),DIMENSION(*)::VA,VB
    REAL(8),DIMENSION(:),ALLOCATABLE::VC
    INTEGER,DIMENSION(*)::IA,JA,IB,JB,IC,JC
    INTEGER,DIMENSION(:),ALLOCATABLE::IW
    ITEMP=IC(NC+1)-1
    CALL SALLOC(ITEMP,VC)
    NCB=NUMINJ(NB,IB,JB)
    CALL SALLOC(NCB,IW)
    LEN=0
    DO IRA=1,NA
       INI=IA(IRA)
       IFI=IA(IRA+1)-1
       DO IZA=INI,IFI
          SCAL=VA(IZA)
          ICA=JA(IZA)
          JNI=IB(ICA)
          JFI=IB(ICA+1)-1
          DO IZB=JNI,JFI
             ICB=JB(IZB)
             IP=IW(ICB)
             IF(IP.EQ.0)THEN
                LEN=LEN+1
                IW(ICB)=LEN
                VC(LEN)=SCAL*VB(IZB)
             ELSE
                VC(IP)=VC(IP)+SCAL*VB(IZB)
             END IF
          END DO
       END DO
    END DO
    CALL SALLOC(0,IW)
  END SUBROUTINE ATIMESBSECONDPART

!-----------
!*** ATIMESB
!-----------
  SUBROUTINE ATIMESB(NA,IA,JA,NB,IB,JB,NC,IC,JC,VA,VB,VC)
    INTEGER,DIMENSION(*)::IA,JA,IB,JB
    INTEGER,DIMENSION(:),ALLOCATABLE::IC,JC
    REAL(8),DIMENSION(*)::VA,VB
    REAL(8),DIMENSION(:),ALLOCATABLE::VC
    CALL ATIMESBFIRSTPART(NA,IA,JA,NB,IB,JB,NC,IC)
    CALL ATIMESBINTERMEDIATEPART(NA,IA,JA,NB,IB,JB,NC,IC,JC)
    CALL ATIMESBSECONDPART(NA,IA,JA,VA,NB,IB,JB,VB,NC,IC,JC,VC)
  END SUBROUTINE ATIMESB

!------------------------
!*** ATIMESB ONLY INDICES
!------------------------
  SUBROUTINE ATIMESBINDEX(NA,IA,JA,NB,IB,JB,NC,IC,JC)
    INTEGER,DIMENSION(*)::IA,JA,IB,JB
    INTEGER,DIMENSION(:),ALLOCATABLE::IC,JC
    CALL ATIMESBFIRSTPART(NA,IA,JA,NB,IB,JB,NC,IC)
    CALL ATIMESBINTERMEDIATEPART(NA,IA,JA,NB,IB,JB,NC,IC,JC)
  END SUBROUTINE ATIMESBINDEX

!------------------
!*** IDENTITYSPARSE
!------------------
  SUBROUTINE IDENTITYSPARSE(NA,IA,JA,A)
    INTEGER,DIMENSION(:),ALLOCATABLE::IA,JA
    REAL(8),DIMENSION(:),ALLOCATABLE::A
    IF(NA.GT.0)THEN
       CALL SALLOC(NA+1,IA)
       DO I=1,NA
          IA(I)=1
       END DO
       CALL SPALLOC1(NA,IA,JA)  
       DO I=1,NA
          JA(IA(I))=I
       ENDDO
       CALL SALLOC(IA(NA+1)-IA(1),A)
       DO I=1,NA
          A(JA(IA(I)))=1.0D00
       END DO
    END IF
  END SUBROUTINE IDENTITYSPARSE

!--------------------
!*** ADDRESS FUNCTION
!--------------------
  INTEGER FUNCTION IADDRESS(IPO,I,J)
    INTEGER,DIMENSION(*)::IPO
    IF(J.EQ.0)THEN
       IADDRESS=IPO(I+1)-IPO(I)
    ELSE
       IADDRESS=IPO(I)-1+J
    END IF
  END FUNCTION IADDRESS

!-------------------------
!*** MAXIMUM COLUMN NUMBER
!-------------------------
  INTEGER FUNCTION NUMINJ(NUM,IPO,LIS)
    INTEGER,DIMENSION(*)::IPO,LIS
    NUM2=0
    DO I=1,IPO(NUM+1)-1
       NUM2=MAX(NUM2,LIS(I))
    END DO
    NUMINJ=NUM2
  END FUNCTION NUMINJ

!------------------------------
!*** BICGSTAB2 SOLUTION, PART I
!------------------------------  
  SUBROUTINE ITERSOLUC(NDOF,ISTIFF,JSTIFF,VSTIFF,SOL,RHS)
    IMPLICIT REAL(8)(A-H,O-Z)
    INTEGER,DIMENSION(*)::ISTIFF,JSTIFF
    REAL(8),DIMENSION(*)::VSTIFF
    REAL(8),DIMENSION(*)::SOL,RHS
    REAL(8),DIMENSION(:),ALLOCATABLE::VEC
    L=1
    TOL1=1.0D-3
    TOL2=TOL1
    TOL=TOL1*10
    ALLOCATE(VEC(NDOF))
    DO IDOF=1,NDOF
       SOL(IDOF)=0.0D00
    END DO
    ITR_MAX=MAX(40,NDOF/200)
    MR=10
    DO I=1,NDOF
       DO K=ISTIFF(I),ISTIFF(I+1)-1
          J=JSTIFF(K)
          IF(I.EQ.J)THEN
             VEC(I)=VSTIFF(K)
          END IF
       END DO
    END DO
    DO I=1,NDOF
       DO K=ISTIFF(I),ISTIFF(I+1)-1
          J=JSTIFF(K)
          IF(ABS(VEC(I)).GT.EPSMACH())THEN
             VSTIFF(K)=VSTIFF(K)/VEC(I)
          END IF
       END DO
       IF(ABS(VEC(I)).GT.EPSMACH())THEN
          RHS(I)=RHS(I)/VEC(I)
       END IF
    END DO
    CALL BICGSTAB2(L,NDOF,SOL,RHS,TOL,INFO,ISTIFF,JSTIFF,VSTIFF)
    DO I=1,NDOF
       DO K=ISTIFF(I),ISTIFF(I+1)-1
          J=JSTIFF(K)
          IF(ABS(VEC(I)).GT.EPSMACH())THEN
             VSTIFF(K)=VSTIFF(K)*VEC(I)
          END IF
       END DO
       IF(ABS(VEC(I)).GT.EPSMACH())THEN
          RHS(I)=RHS(I)*VEC(I)
       END IF
    END DO
  END SUBROUTINE ITERSOLUC

!-------------
!*** BICGSTAB2
!-------------
  SUBROUTINE BICGSTAB2(L,N,X,RHS,TOL,INFO,IA,JA,VA)
! THIS IS THE "VANILLA" VERSION OF BI!GSTAB(\ELL) AS DESCRIBED
! IN PHD THESIS OF D.R.FOKKEMA, !HAPTER 3.  IT INCLUDES TWO ENHANCEMENTS
! TO BI!GSTAB(\ELL) PROPOSED BY G.SLEIJPEN AND H.VAN DER VORST IN
! 1) G.SLEIJPEN AND H.VAN DER VORST "MAINTAINING CONVERGENCE
!    PROPERTIES OF BI!GSTAB METHODS IN FINITE PRECISION ARITHMETIC",
!    NUMERICAL ALGORITHMS, 10, 1995, PP.203-223
! 2) G.SLEIJPEN AND H.VAN DER VORST "RELIABLE UPDATED RESIDUALS IN
!    HYBRID BI!G METHODS", !OMPUTING, 56, 1996, PP.141-163
!
! {{ THIS CODE BASED ON:
! SUBROUTINE BISTBL V1.0 1995
!
! !OPYRIGHT (C) 1995 BY D.R. FOKKEMA.
! PERMISSION TO COPY ALL OR PART OF THIS WORK IS GRANTED,
! PROVIDED THAT THE COPIES ARE NOT MADE OR DISTRIBUTED
! FOR RESALE, AND THAT THE COPYRIGHT NOTICE AND THIS
! NOTICE ARE RETAINED.  }}
!
! L       == (INPUT) INTEGER BI!GSTAB'S DIMENSION <= 2
!            SET L=2 FOR HIGHLY NONSYMMETRIC PROBLEMS
! N       == (INPUT) INTEGER SIZE OF THE SYSTEM TO SOLVE
! X       == (INPUT/OUTPUT) DOUBLE PRE!ISION ARRAY DIMENSION N
!            INITIAL GUESS ON INPUT, SOLUTION ON OUTPUT
! RHS     == (INPUT) DOUBLE PRE!ISION ARRAY DIMENSION N
!            RIGHT-HAND SIDE (RHS) VECTOR
! TOL     == (INPUT/OUTPUT) DOUBLE PRE!ISION TOLERANCE FOR ALL POSSIBLE
!            STOPPING CRITERIA (SEE THE 'TYPESTOP' PARAMETER)
!            ON OUTPUT, IF INFO=0 OR 1, TOL IS ACTUALLY ACHIEVED
!            RESIDUAL REDUCTION OR WHATEVER (SEE THE 'TYPESTOP' PARAMETER)
! TYPESTOP== (INPUT) !HARA!TER*3 STOPPING CRITERION (||.|| DENOTES
!            THE 2-NORM):
!            TYPESTOP='REL' -- RELATIVE STOPPING CRIT.: ||RES|| < TOL*||RES0||
!            TYPESTOP='ABS' -- ABSOLUTE STOPPING CRIT.: ||RES||<TOL
!            TYPESTOP='MAX' -- MAXIMUM  STOPPING CRIT.: MAX(ABS(RES))<TOL
! NOTE(FOR TYPESTOP='REL' AND 'ABS'): TO SAVE COMPUTATIONAL WORK, THE VALUE OF
!            RESIDUAL NORM USED TO CHECK THE CONVERGENCE INSIDE THE MAIN ITERATIVE
!            LOOP IS COMPUTED FROM
!            PROJECTIONS, I.E. IT CAN BE SMALLER THAN THE TRUE RESIDUAL NORM
!            (IT MAY HAPPEN WHEN E.G. THE 'MATRIX-FREE' APPROACH IS USED).
!            THUS, IT IS POSSIBLE THAT THE TRUE RESIDUAL DOES NOT SATISFY
!            THE STOPPING CRITERION ('REL' OR 'ABS').
!            THE TRUE RESIDUAL NORM (OR RESIDUAL REDUCTION) IS REPORTED ON
!            OUTPUT IN PARAMETER TOL -- THIS CAN BE CHANGED TO SAVE 1 MATVE!
!            (SEE COMMENTS AT THE END OF THE SUBROUTINE)
! MXMV   ==  (INPUT/OUTPUT) INTEGER.  ON INPUT: MAXIMUM NUMBER OF MATRIX
!            VECTOR MULTIPLICATIONS ALLOWED TO BE DONE.  ON OUTPUT:
!            ACTUAL NUMBER OF MATRIX VECTOR MULTIPLICATIONS DONE
! WORK   ==  (WORKSPACE) DOUBLE PRE!ISION ARRAY DIMENSION (N,2*L+5))
! LDW    ==  (INPUT) INTEGER SIZE OF WORK, I.E. LDW >= N*(2*L+5)
! INFO   ==  (OUTPUT) INTEGER.  INFO = 0 IN CASE OF NORMAL COMPUTATIONS
!            AND
!            INFO = -M (<0) - MEANS PARAMATER NUMBER M HAS AN ILLEGAL VALUE
!            INFO = 1 - MEANS NO CONVERGENCE ACHIEVED (STOPPING CRITERION
!            IS NOT FULFILLED)
!            INFO = 2 - MEANS BREAKDOWN OF THE ALGORITHM (TRY TO ENLARGE
!            PARAMETER L=\ELL TO GET RID OF THIS)
! ----------------------------------------------------------
    IMPLICIT NONE
    INTEGER L, N, MXMV, LDW, INFO
    DOUBLE PRECISION  X(N), RHS(N), TOL
    REAL(8),DIMENSION(*)::VA
    REAL(8),DIMENSION(:,:),ALLOCATABLE::WORK,RWORK
    INTEGER   LMAX
    PARAMETER(LMAX=2)


    LOGICAL GOON, RCMP, XPDT
    INTEGER II, I1, JJ, KK, NMV
    DOUBLE PRECISION ALPHA,BETA,HATGAMMA,KAPPA0, KAPPAL,MAXVAL1,MXNRMR,MXNRMX,OMEGA,RHO0,RHO1,RNRM0,RNRM,RNRMMAX,SIGMA,SUM1,VARRHO
    INTEGER Z, ZZ, Y0, YL, Y
    INTEGER RR, R, U, XP, BP

    DOUBLE PRECISION    ZERO, ONE, DELTA
    INTEGER IA(*),JA(*)
    PARAMETER(ZERO=0D0,ONE=1D0,DELTA=1D-2)
    ALLOCATE(RWORK(LMAX+1,3+2*(LMAX+1)))
    ALLOCATE(WORK(N,5+2*L))
    LDW=N*(2*L+5)
    MXMV=MAX(20,N/5)
    INFO = 0
    IF (L.GT.LMAX .OR. L.LT.1) INFO = -2
    IF (TOL.LE.ZERO) INFO = -8
    IF (MXMV.LT.0) INFO = -10
    RR = 1
    R = RR+1
    U = R+(L+1)
    XP = U+(L+1)
    BP = XP+1
    IF (BP*N.GT.LDW) INFO = -12
    Z = 1
    ZZ = Z+(L+1)
    Y0 = ZZ+(L+1)
    YL = Y0+1
    Y = YL+1
    IF (INFO.NE.0) RETURN
    CALL ATIMESV(N,IA,JA,VA,X,WORK(1,R))
!  CALL MATVEC (N, X, WORK(1,R) )
    DO II=1,N
       WORK(II,R) = RHS(II) - WORK(II,R)
    ENDDO
    NMV = 1
    SUM1 = ZERO
    DO II=1,N
       WORK(II,RR) = WORK(II,R)
       WORK(II,BP) = WORK(II,R)
       WORK(II,XP) = X(II)
       X(II) = ZERO
       SUM1=SUM1+ WORK(II,R)**2
    ENDDO
    RNRM0 = SQRT( SUM1 )
    RNRM = RNRM0

    MXNRMX = RNRM0
    MXNRMR = RNRM0
    RCMP = .FALSE.
    XPDT = .FALSE.

    ALPHA = ZERO
    OMEGA = ONE
    SIGMA = ONE
    RHO0 =  ONE

!     ITERATE
!  WRITE(*,*)"RNRM0,RNRM",RNRM0,RNRM
    GOON = RNRM.GE.TOL*RNRM0 .AND. NMV.LT.MXMV

    DO WHILE (GOON)
!     =====================
!     --- THE BI!G PART ---
!     =====================
       RHO0 = -OMEGA*RHO0
       DO KK=1,L
          SUM1 = ZERO
          DO II=1,N
             SUM1=SUM1+ WORK(II,RR)*WORK(II,R+KK-1)
          ENDDO
          RHO1 = SUM1

          IF (RHO0.EQ.ZERO) THEN
             INFO = 2
             RETURN
          ENDIF
          BETA = ALPHA*(RHO1/RHO0)
          RHO0 = RHO1
          DO JJ=0,KK-1
             DO II=1,N
                WORK(II,U+JJ) = WORK(II,R+JJ) - BETA*WORK(II,U+JJ)
             ENDDO
          ENDDO
          CALL ATIMESV(N,IA,JA,VA,WORK(1,U+KK-1),WORK(1,U+KK))
!        CALL MATVEC(N, WORK(1,U+KK-1), WORK(1,U+KK))
          NMV = NMV+1

          SUM1 = ZERO
          DO II=1,N
             SUM1=SUM1+ WORK(II,RR)*WORK(II,U+KK)
          ENDDO
          SIGMA = SUM1

          IF (SIGMA.EQ.ZERO) THEN
             INFO = 2
             RETURN
          ENDIF

          ALPHA = RHO1/SIGMA
          DO II=1,N
             X(II) = ALPHA*WORK(II,U) + X(II)
          ENDDO

          DO JJ=0,KK-1
             DO II=1,N
                WORK(II,R+JJ) = -ALPHA*WORK(II,U+JJ+1) + WORK(II,R+JJ)
             ENDDO
          ENDDO
          CALL ATIMESV(N,IA,JA,VA,WORK(1,R+KK-1),WORK(1,R+KK))
!        CALL MATVEC (N, WORK(1,R+KK-1), WORK(1,R+KK))
          NMV = NMV+1

          SUM1 = ZERO
          DO II=1,N
             SUM1=SUM1+ WORK(II,R)**2
          ENDDO
          RNRM = SQRT( SUM1 )

          MXNRMX = MAX (MXNRMX, RNRM)
          MXNRMR = MAX (MXNRMR, RNRM)
       ENDDO

!     ==================================
!     --- THE CONVEX POLYNOMIAL PART ---
!     ==================================

!        Z = R'R
       DO I1=1,L+1
          DO JJ=I1-1,L
             SUM1 = ZERO
             DO II=1,N
                SUM1=SUM1+ WORK(II,R+JJ)*WORK(II,R+I1-1)
             ENDDO
             RWORK(JJ+1,Z+I1-1) = SUM1
             RWORK(Z+I1-1,JJ+1) = RWORK(JJ+1,Z+I1-1)
          ENDDO
       ENDDO

       DO I1=ZZ,ZZ+L
          DO II=1,L+1
             RWORK(II,I1)   = RWORK(II,I1+(Z-ZZ))
          ENDDO
       ENDDO
!        TILDE R0 AND TILDE RL (SMALL VECTORS)

       RWORK(1,Y0) = -ONE
       RWORK(2,Y0) = RWORK(2,Z) / RWORK(2,ZZ+1)
       RWORK(L+1,Y0) = ZERO

       RWORK(1,YL) = ZERO
       RWORK(2,YL) = RWORK(2,Z+L) / RWORK(2,ZZ+1)
       RWORK(L+1,YL) = -ONE

!        !ONVEX COMBINATION
       DO II=1,L+1
          RWORK(II,Y) = ZERO
       ENDDO
       DO JJ=1,L+1
          DO II=1,L+1
             RWORK(II,Y) = RWORK(II,Y) + RWORK(JJ,YL)* RWORK(II,Z+JJ-1)
          ENDDO
       ENDDO
       SUM1 = ZERO
       DO II=1,L+1
          SUM1=SUM1+ RWORK(II,YL)*RWORK(II,Y)
       ENDDO
       KAPPAL = SQRT( SUM1 )

       DO II=1,L+1
          RWORK(II,Y) = ZERO
       ENDDO
       DO JJ=1,L+1
          DO II=1,L+1
             RWORK(II,Y) = RWORK(II,Y) + RWORK(JJ,Y0)*   RWORK(II,Z+JJ-1)
          ENDDO
       ENDDO
       SUM1 = ZERO
       DO II=1,L+1
          SUM1=SUM1+ RWORK(II,Y0)*RWORK(II,Y)
       ENDDO
       KAPPA0 = SQRT( SUM1 )

       SUM1 = ZERO
       DO II=1,L+1
          SUM1=SUM1+ RWORK(II,YL)*RWORK(II,Y)
       ENDDO
       VARRHO = SUM1
       VARRHO = VARRHO / (KAPPA0*KAPPAL)

       HATGAMMA = SIGN(1D0,VARRHO)*MAX(ABS(VARRHO),7D-1) *  (KAPPA0/KAPPAL)

       DO II=1,L+1
          RWORK(II,Y0) = -HATGAMMA*RWORK(II,YL) +      RWORK(II,Y0)
       ENDDO

!        UPDATE
       OMEGA = RWORK(L+1,Y0)
       DO JJ=1,L
          DO II=1,N
             WORK(II,U) = WORK(II,U) - RWORK(1+JJ,Y0)*WORK(II,U+JJ)
             X(II)      = X(II)      + RWORK(1+JJ,Y0)*WORK(II,R+JJ-1)
             WORK(II,R) = WORK(II,R) - RWORK(1+JJ,Y0)*WORK(II,R+JJ)
          ENDDO
       ENDDO

       DO II=1,L+1
          RWORK(II,Y) = ZERO
       ENDDO
       DO JJ=1,L+1
          DO II=1,L+1
             RWORK(II,Y) = RWORK(II,Y) + RWORK(JJ,Y0)*    RWORK(II,Z+JJ-1)
          ENDDO
       ENDDO

       SUM1 = ZERO
       DO II=1,L+1
          SUM1=SUM1+ RWORK(II,Y0)*RWORK(II,Y)
       ENDDO
       RNRM = SQRT( SUM1 )

!     ================================
!     --- THE RELIABLE UPDATE PART ---
!     ================================
       MXNRMX = MAX (MXNRMX, RNRM)
       MXNRMR = MAX (MXNRMR, RNRM)
       XPDT = (RNRM.LT.DELTA*RNRM0.AND.RNRM0.LT.MXNRMX)
       RCMP = ((RNRM.LT.DELTA*MXNRMR.AND.RNRM0.LT.MXNRMR) .OR.XPDT)
       IF (RCMP) THEN
          CALL ATIMESV(N,IA,JA,VA,X,WORK(1,R))
!        CALL MATVEC (N, X, WORK(1,R) )
          NMV = NMV + 1
          DO II=1,N
             WORK(II,R) = WORK(II,BP) - WORK(II,R)
          ENDDO
          MXNRMR = RNRM
          IF (XPDT) THEN
             DO II=1,N
                WORK(II,XP) = X(II) + WORK(II,XP)
                X(II) = ZERO
                WORK(II,BP) = WORK(II,R)
             ENDDO
             MXNRMX = RNRM
          ENDIF
       ENDIF
!     WRITE(*,*)"RNRM0,RNRM",RNRM0,RNRM
       GOON = RNRM.GE.TOL*RNRM0 .AND. NMV.LT.MXMV

    ENDDO

!     =========================
!     --- END OF ITERATIONS ---
!     =========================

    DO II=1,N
       X(II) = WORK(II,XP) + X(II)
    ENDDO

    CALL ATIMESV(N,IA,JA,VA,X,WORK(1,R))
!  CALL MATVEC (N, X, WORK(1,R) )
    DO II=1,N
       WORK(II,R) = RHS(II) - WORK(II,R)
    ENDDO

    SUM1 = ZERO
    DO II=1,N
       SUM1=SUM1+ WORK(II,R)**2
    ENDDO
    RNRM = SQRT( SUM1 )

    IF (RNRM.GT.TOL*RNRM0) INFO = 1
    TOL = RNRM/RNRM0

    MXMV = NMV

    RETURN
  END SUBROUTINE BICGSTAB2

!----------------------------------
!*** IN PLACE PERMUTATION OF A LIST
!----------------------------------
  SUBROUTINE IVPERM (N, IX, PERM)
    INTEGER N, PERM(N), IX(N)
    INTEGER TMP, TMP1
    INIT      = 1
    TMP	= IX(INIT)
    II        = PERM(INIT)
    PERM(INIT)= -PERM(INIT)
    K         = 0
6   K = K+1
    TMP1	  = IX(II)
    IX(II)     = TMP
    NEXT	  = PERM(II)
    IF (NEXT .LT. 0 ) GOTO 65
    IF (K .GT. N) GOTO 101
    TMP       = TMP1
    PERM(II)  = - PERM(II)
    II        = NEXT
    GOTO 6
65  INIT      = INIT+1
    IF (INIT .GT. N) GOTO 101
    IF (PERM(INIT) .LT. 0) GOTO 65
    TMP	= IX(INIT)
    II	= PERM(INIT)
    PERM(INIT)=-PERM(INIT)
    GOTO 6
101 CONTINUE
    DO J=1, N
       PERM(J) = -PERM(J)
    END DO
    RETURN
  END SUBROUTINE IVPERM

!------------------------------------
!*** IN PLACE PERMUTATION OF A VECTOR
!------------------------------------
  SUBROUTINE DVPERM (N, IX, PERM)
    IMPLICIT REAL(8)(A-H,O-Z)
    INTEGER N, PERM(N)
    REAL(8) IX(N)
    INIT      = 1
    TMP	= IX(INIT)
    II        = PERM(INIT)
    PERM(INIT)= -PERM(INIT)
    K         = 0
6   K = K+1
    TMP1	  = IX(II)
    IX(II)     = TMP
    NEXT	  = PERM(II)
    IF (NEXT .LT. 0 ) GOTO 65
    IF (K .GT. N) GOTO 101
    TMP       = TMP1
    PERM(II)  = - PERM(II)
    II        = NEXT
    GOTO 6
65  INIT      = INIT+1
    IF (INIT .GT. N) GOTO 101
    IF (PERM(INIT) .LT. 0) GOTO 65
    TMP	= IX(INIT)
    II	= PERM(INIT)
    PERM(INIT)=-PERM(INIT)
    GOTO 6
101 CONTINUE
    DO J=1, N
       PERM(J) = -PERM(J)
    END DO
    RETURN
  END SUBROUTINE DVPERM

!--------------------------------------
!*** SORTS COLUMNS
!*** SO THAT BINARY SEARCH CAN BE USED
!--------------------------------------
  SUBROUTINE SPCOLSORT(NRA,IA,JA,VA)
    IMPLICIT REAL(8)(A-H,O-Z)
    INTEGER,DIMENSION(*)::IA,JA
    INTEGER,DIMENSION(:),ALLOCATABLE::IWORK
    REAL(8),DIMENSION(*),OPTIONAL::VA
    CALL SALLOC(MAX(NRA+1,2*(IA(NRA+1)-IA(1))),IWORK)
    M=0
    DO I=1,NRA
       DO K=IA(I),IA(I+1)-1
          M=MAX(M,JA(K))
       END DO
    END DO
    DO I=1,NRA
       DO K=IA(I),IA(I+1)-1
          J=JA(K)+1
          IWORK(J)=IWORK(J)+1
       END DO
    END DO
    IWORK(1)=1
    DO I=1,NRA
       IWORK(I+1)=IWORK(I)+IWORK(I+1)
    END DO
    IFIRST=IA(1)
    NNZ=IA(NRA+1)-IFIRST
    DO I=1,NRA
       DO K=IA(I),IA(I+1)-1
          J=JA(K)
          NEXT=IWORK(J)
          IWORK(NNZ+NEXT)=K
          IWORK(J)=NEXT+1
       END DO
    END DO
    DO I=1,NRA
       DO  K=IA(I), IA(I+1)-1
          IWORK(K) = I
       END DO
    END DO
    DO  K=1, NNZ
       KO = IWORK(NNZ+K)
       IROW = IWORK(KO)
       NEXT = IA(IROW)
       IWORK(KO) = NEXT
       IA(IROW)  = NEXT+1
    END DO
    CALL IVPERM (NNZ, JA(IFIRST), IWORK)
    IF (PRESENT(VA))CALL DVPERM(NNZ, VA(IFIRST), IWORK)
    DO  I=NRA,1,-1
       IA(I+1) = IA(I)
    END DO
    IA(1) = IFIRST
  END SUBROUTINE SPCOLSORT

!--------------------------
!*** CLEANS UP THE RELATION
!*** PROVIDES CLEANED JA
!--------------------------
  SUBROUTINE CLEANSUP(NRA,IA,JA)
    INTEGER,DIMENSION(:)::IA,JA
    INTEGER,DIMENSION(:),ALLOCATABLE::ICOLSP
    NNZ=NUMINJ(NRA,IA,JA)
    CALL SALLOC(NNZ,ICOLSP)
    IL=0
    DO I=1,NRA
       NS=IA(I)
       NF=IA(I+1)-1
       IA(I)=0
       DO J=NS,NF
          IF(JA(J).GT.0)ICOLSP(JA(J))=0
       END DO
       DO J=NS,NF
          K=JA(J)
          IF(K.GT.0)THEN
             IF(ICOLSP(K).EQ.0)THEN
                IA(I)=IA(I)+1
                IL=IL+1
                JA(IL)=K
                ICOLSP(K)=IL
             END IF
          END IF
       END DO
    END DO
    IF(NRA.LE.0)RETURN
    CALL MUDLIS(NRA,IA)
    DO I=IL+1,IA(NRA+1)-1
       JA(I)=0
    END DO
  END SUBROUTINE CLEANSUP

!------------------------------------------------------------
!*** CONTRACTS: REMOVES NON-POSITIVE ELEMENTS, DETERMINES NCA
!*** ADDS REPEATED, ETC..
!*** AND CALCULATES IAT
!*** GIVEN:NRA,IA,JA
!*** CALCULATED:IA,JA,NCA,IAT
!------------------------------------------------------------
  SUBROUTINE REMOVENPOS(NRA,NCA,IA,IAT,JAT,VA)
    REAL(8)::RTEMP
    LOGICAL::IDETNCA=.FALSE.
    INTEGER,DIMENSION(*)::IA,JAT
    REAL(8),DIMENSION(*),OPTIONAL::VA
    INTEGER,DIMENSION(:),ALLOCATABLE::IAT,ICOLSP
    NNZ=NUMINJ(NRA,IA,JAT)
    IDETNCA=.FALSE.
    IF(NCA.LE.0)IDETNCA=.TRUE.
    CALL SALLOC(NNZ,ICOLSP)
    IL=0
    IF(PRESENT(VA))THEN
       DO I=1,NRA
          NS=IA(I)
          NF=IA(I+1)-1
          IA(I)=0
          DO J=NS,NF
             K=JAT(J)
             IF(K.GT.0)ICOLSP(K)=0
          END DO
          DO J=NS,NF
             K=JAT(J)
             RTEMP=VA(J)
             IF(K.GT.0.AND.RTEMP.NE.0.0D00)THEN
                IF(ICOLSP(K).EQ.0)THEN
                   IF(IDETNCA)NCA=MAX(NCA,K)
                   IA(I)=IA(I)+1
                   IL=IL+1
                   JAT(IL)=K
                   VA(IL)=RTEMP
                   ICOLSP(K)=IL
                ELSE
                   VA(ICOLSP(K))=VA(ICOLSP(K))+RTEMP
                END IF
             END IF
          END DO
       END DO
    ELSE
       DO I=1,NRA
          NS=IA(I)
          NF=IA(I+1)-1
          IA(I)=0
          DO J=NS,NF
             K=JAT(J)
             IF(K.GT.0)ICOLSP(K)=0
          END DO
          DO J=NS,NF
             K=JAT(J)
             IF(K.GT.0)THEN
                IF(ICOLSP(K).EQ.0)THEN
                   IF(IDETNCA)NCA=MAX(NCA,K)
                   IA(I)=IA(I)+1
                   IL=IL+1
                   JAT(IL)=K
                   ICOLSP(K)=IL
                END IF
             END IF
          END DO
       END DO
    END IF
    IF(NRA.GT.0)THEN
       CALL MUDLIS(NRA,IA)
       DO I=IL+1,IA(NRA+1)-1
          JAT(I)=0
       END DO
       CALL SALLOC(NCA+1,IAT)
       DO I=1,NRA
          DO J=IA(I),IA(I+1)-1
             K=JAT(J)
             IAT(K)=IAT(K)+1
          END DO
       END DO
       CALL MUDLIS(NCA,IAT)
    END IF
  END SUBROUTINE REMOVENPOS

!-------------------------
!*** LIST IN
!*** 5, 3, 1, 2, 4, ?
!*** LIST OUT
!*** 1, 6, 9,10,12,16
!*** ATTENTION DIMENSIONS:
!*** LIST(N+1)
!-------------------------
  SUBROUTINE MUDLIS(N,LIST)
    INTEGER,DIMENSION(*)::LIST
    IF(N.LE.0)RETURN
    LOL=LIST(1)
    LIST(1)=1
    DO IN=1,N
       NEWV=LIST(IN)+LOL
       IN1=IN+1
       LOL=LIST(IN1)
       LIST(IN1)=NEWV
    ENDDO
  END SUBROUTINE MUDLIS

!-----------------------
!*** PUTS THE STUFF BACK
!-----------------------
  SUBROUTINE MUDLIS2(N,LIST)
    INTEGER,DIMENSION(*)::LIST
    IF(N.LE.0)RETURN
    DO I=N,1,-1
       LIST(I+1)=LIST(I)
    END DO
    LIST(1)=1
  END SUBROUTINE MUDLIS2

!--------------------------------
!*** INVIND
!*** JUST CALLS SPARSETRANSPINDEX
!--------------------------------
  SUBROUTINE INVIND(NRA,NCA,IA,IAT,JA,JAT)
    INTEGER,DIMENSION(*)::IA,JA
    INTEGER,DIMENSION(:),ALLOCATABLE::IAT,JAT,IJA
    CALL SPARSETRANSPINDEX(NRA,NCA,IA,JA,IJA,IAT,JAT) 
  END SUBROUTINE INVIND

!--------------------
!*** SPARSE TRANSPOSE
!*** WITH VALUES
!--------------------
  SUBROUTINE SPARSETRANSP(NRA,NCA,IA,JA,VA,IAT,JAT,VAT)
    INTEGER::RA,CA
    INTEGER,DIMENSION(*)::IA,JA
    REAL(8),DIMENSION(*)::VA
    INTEGER,DIMENSION(:),ALLOCATABLE::IAT,JAT
    REAL(8),DIMENSION(:),ALLOCATABLE::VAT
    CALL SALLOC(NCA+1,IAT)
    DO RA=1,NRA
       DO KA=IA(RA),IA(RA+1)-1
          CA=JA(KA)
          IAT(CA)=IAT(CA)+1
       END DO
    END DO
    CALL MUDLIS(NCA,IAT)
    ITEMP=IAT(NCA+1)-1
    CALL SALLOC(ITEMP,JAT)
    CALL SALLOC(ITEMP,VAT)
    DO RA=1,NRA
       DO KA=IA(RA),IA(RA+1)-1
          CA=JA(KA)
          NEXTV=IAT(CA)
          IAT(CA)=NEXTV+1
          JAT(NEXTV)=RA
          VAT(NEXTV)=VA(KA)
       ENDDO
    ENDDO
    DO CA=NCA,1,-1
       IAT(CA+1)=IAT(CA)
    END DO
    IAT(1)=1
  END SUBROUTINE SPARSETRANSP

!--------------------
!*** SPARSE TRANSPOSE
!*** ONLY INDICES
!--------------------
  SUBROUTINE SPARSETRANSPINDEX(NRA,NCA,IA,JA,IJA,IAT,JAT)
    INTEGER::RA,CA
    INTEGER,DIMENSION(*)::IA,JA
    INTEGER,DIMENSION(:),ALLOCATABLE::IAT,JAT,IJA
    CALL SALLOC(NCA+1,IAT)
    DO RA=1,NRA
       DO KA=IA(RA),IA(RA+1)-1
          CA=JA(KA)
          IAT(CA)=IAT(CA)+1
       END DO
    END DO
    CALL MUDLIS(NCA,IAT)
    ITEMP=IAT(NCA+1)-1
    CALL SALLOC(ITEMP,JAT)
    CALL SALLOC(ITEMP,IJA)
    DO RA=1,NRA
       IK=0
       DO KA=IA(RA),IA(RA+1)-1
          IK=IK+1
          CA=JA(KA)
          NEXTV=IAT(CA)
          IAT(CA)=NEXTV+1
          JAT(NEXTV)=RA
          IJA(NEXTV)=IK
       ENDDO
    ENDDO
    DO CA=NCA,1,-1
       IAT(CA+1)=IAT(CA)
    END DO
    IAT(1)=1
  END SUBROUTINE SPARSETRANSPINDEX

!----------------------
!*** ROW PERMUTATIONS
!*** OF A SPARSE MATRIX
!----------------------
  SUBROUTINE ROWPERM(NRA,IA,JA,VA,IANEW,JANEW,VANEW,NEWOLD)
    INTEGER::RA
    INTEGER,DIMENSION(*)::IA,JA,IANEW,JANEW,NEWOLD
    REAL(8),DIMENSION(*)::VA,VANEW
    DO RA=1,NRA
       IANEW(NEWOLD(RA)+1)=IA(RA+1)-IA(RA)
    END DO
    IANEW(1)=1
    DO RA=1,NRA
       IANEW(RA+1)=IANEW(RA+1)+IANEW(RA)
    END DO
    DO RA=1,NRA
       KO=IANEW(NEWOLD(RA))-1
       DO KA=IA(RA),IA(RA+1)-1
          KO=KO+1
          JANEW(KO)=JA(KA)
          VANEW(KO)=VA(KA)
       END DO
    END DO
  END SUBROUTINE ROWPERM

!-----------------------
!*** COLUMN PERMUTATIONS
!-----------------------
  SUBROUTINE COLPERM(NRA,IA,JA,VA,IANEW,JANEW,VANEW,NEWOLD)
    INTEGER::RA,KZ
    INTEGER,DIMENSION(*)::IA,JA,IANEW,JANEW,NEWOLD
    REAL(8),DIMENSION(*)::VA,VANEW
    NNZ=IA(NRA+1)-1
    DO KZ=1,NNZ
       JANEW(KZ)=NEWOLD(JA(KZ))
    END DO
    IF(LOC(IA(1)).NE.LOC(IANEW(1)))THEN
       DO RA=1,NRA+1
          IANEW(RA)=IA(RA)
       END DO
       DO KZ=1,NNZ
          VANEW(KZ)=VA(KZ)
       END DO
    END IF
  END SUBROUTINE COLPERM

!-------------------------------------------
!*** ROW AND COLUMN PERMUTATIONS (SYMMETRIC)
!-------------------------------------------
  SUBROUTINE ROWCOLPERM(NRA,IA,JA,VA,IANEW,JANEW,VANEW,NEWOLD)
    INTEGER,DIMENSION(*)::IA,JA,NEWOLD,IANEW,JANEW
    REAL(8),DIMENSION(*)::VA,VANEW
    CALL ROWPERM(NRA,IA,JA,VA,IANEW,JANEW,VANEW,NEWOLD)
    CALL COLPERM(NRA,IANEW,JANEW,VANEW,IANEW,JANEW,VANEW,NEWOLD)
  END SUBROUTINE ROWCOLPERM

!-------------------------------------------
!*** GIVEN NUM1 AND LIS1 CALCULATES THE REST
!*** LIS1: 3 5 1
!*** IPO2: 1 2 2 3 3 4
!*** LIS2: 3 1 2
!-------------------------------------------  
  SUBROUTINE INVIND_ONE(NUM1,NUM2,IPO2,LIS1,LIS2)
    INTEGER,DIMENSION(*)::LIS1
    INTEGER,DIMENSION(:),ALLOCATABLE::IPO2,LIS2
    IF(NUM1.LE.0)RETURN
    N=NUM1
    IF(NUM2.EQ.0)THEN
       NUM2=0
       DO I=1,N
          NUM2=MAX(NUM2,LIS1(I))
       END DO
    END IF
    IF(NUM2.LE.0.OR.NUM1.LE.0)RETURN
    IF(ALLOCATED(IPO2))DEALLOCATE(IPO2)
    ALLOCATE(IPO2(NUM2+1));CALL PCONSI(NUM2+1,IPO2,0)
    DO I=1,NUM1
       J=LIS1(I)
       IPO2(J)=IPO2(J)+1
    END DO
    CALL MUDLIS(NUM2,IPO2)
    IF(ALLOCATED(LIS2))DEALLOCATE(LIS2)
    ALLOCATE(LIS2(IPO2(NUM2+1)-1))
    DO I=1,NUM1
       J=LIS1(I)
       NEXTV=IPO2(J)
       IPO2(J)=NEXTV+1
       LIS2(NEXTV)=I
    END DO
    CALL MUDLIS2(NUM2,IPO2)
  END SUBROUTINE INVIND_ONE

!----------------------------------------------
!*** MAKES A POSTSCRIPT PLOT OF A SPARSE MATRIX
!----------------------------------------------  
  SUBROUTINE PLTMTPS (NA,IA,JA,NAME,IUNT,SIZE)
    IMPLICIT REAL(8)(A-H,O-Z)
    INTEGER,DIMENSION(*)::IA,JA
    CHARACTER(*)::NAME
    CHARACTER(3)::MUNT
    MUNT="CM"
    HAF=0.5D00
    ZERO=0.0D00
    CONV=2.54D00
    NROW=NA
    NCOL=NUMINJ(NA,IA,JA)
    SIZ = SIZE
    NR = NROW
    NC = NCOL
    N = NC
    N = NR
    MAXDIM = MAX(NROW, NCOL)
    M = 1 + MAXDIM
    NC = NC+1
    NR = NR+1
    IF (MUNT.EQ.'CM' .OR. MUNT.EQ.'CM') THEN
       U2DOT = 72.0/CONV
       PAPERX = 21.0
    ELSE
       U2DOT = 72.0
       PAPERX = 8.5*CONV
       SIZ = SIZ*CONV
    END IF
    LRMRGN = (PAPERX-SIZ)/2.0
    BOTMRGN = 2.0
    SCFCT = SIZ*U2DOT/M
    FRLW = 0.25
    FNSTIT = 0.5
    LTIT = LEN_TRIM(NAME)
    YTITOF = 1.0
    XTIT = PAPERX/2.0
    YTIT = BOTMRGN+SIZ*NR/M + YTITOF
    XL = LRMRGN*U2DOT - SCFCT*FRLW/2
    XR = (LRMRGN+SIZ)*U2DOT + SCFCT*FRLW/2
    YB = BOTMRGN*U2DOT - SCFCT*FRLW/2
    YT = (BOTMRGN+SIZ*NR/M)*U2DOT + SCFCT*FRLW/2
    IF (LTIT.GT.0) THEN
       YT = YT + (YTITOF+FNSTIT*0.70)*U2DOT
    END IF
    DELT = 10.0
    XL = XL-DELT
    XR = XR+DELT
    YB = YB-DELT
    YT = YT+DELT
    WRITE(IUNT,10) '%!'
    WRITE(IUNT,10) '%%CREATOR: PSPLTM ROUTINE'
    WRITE(IUNT,12) '%%BOUNDINGBOX:',XL,YB,XR,YT
    WRITE(IUNT,10) '%%ENDCOMMENTS'
    WRITE(IUNT,10) '/CM {72 MUL 2.54 DIV} DEF'
    WRITE(IUNT,10) '/MC {72 DIV 2.54 MUL} DEF'
    WRITE(IUNT,10) '/PNUM { 72 DIV 2.54 MUL 20 STRING'
    WRITE(IUNT,10) 'CVS PRINT ( ) PRINT} DEF'
    WRITE(IUNT,10) '/CSHOW {DUP STRINGWIDTH POP -2 DIV 0 RMOVETO SHOW} DEF'
    WRITE(IUNT,10) 'GSAVE'
    IF (LTIT.GT.0) THEN
       WRITE(IUNT,*) '/HELVETICA FINDFONT ',FNSTIT,' CM SCALEFONT SETFONT '
       WRITE(IUNT,*) XTIT,' CM ',YTIT,' CM MOVETO '
       WRITE(IUNT,'(3A)') '(',NAME(1:LTIT),') CSHOW'
    END IF
    WRITE(IUNT,*) LRMRGN,' CM ',BOTMRGN,' CM TRANSLATE'
    WRITE(IUNT,*) SIZ,' CM ',M,' DIV DUP SCALE '
    WRITE(IUNT,*) FRLW,' SETLINEWIDTH'
    WRITE(IUNT,10) 'NEWPATH'
    WRITE(IUNT,11) 0, 0, ' MOVETO'
    WRITE(IUNT,11) NC,0,' LINETO'
    WRITE(IUNT,11) NC,NR,' LINETO'
    WRITE(IUNT,11) 0,NR,' LINETO'
    WRITE(IUNT,10) 'CLOSEPATH STROKE'
    WRITE(IUNT,*)  ' 0.2 SETLINEWIDTH'
    WRITE(IUNT,10) '1 1 TRANSLATE'
    WRITE(IUNT,10) '0.8 SETLINEWIDTH'
    WRITE(IUNT,10) '/P {MOVETO 0 -.40 RMOVETO '
    WRITE(IUNT,10) '           0  .80 RLINETO STROKE} DEF'
    DO II=1, NROW
       ISTART = IA(II)
       ILAST  = IA(II+1)-1
       DO K=ISTART, ILAST
          WRITE(IUNT,11) JA(K)-1, NROW-II, ' P'
       END DO
    END DO
    WRITE(IUNT,10) 'SHOWPAGE'
    RETURN
10  FORMAT (A)
11  FORMAT (2(I6,1X),A)
12  FORMAT (A,4(1X,F9.2))
13  FORMAT (2(F9.2,1X),A)
  END SUBROUTINE PLTMTPS

!-------------------------------
!*** CSC SPARSEDENSE LX=B WITH L
!*** BEING LOWER TRIANGULAR
!*** AND SPARSE
!*** DIAGONALS ARE AT IL(RL)
!*** THE BEGGINING OF EACH LINE
!----------------------------------------
  SUBROUTINE SPARSEDENSELXBCSC(NRL,IL,JL,VX,X,B)
    IMPLICIT REAL(8)(A-H,O-Z)
    REAL(8),DIMENSION(NRL)::X,B
    REAL(8),DIMENSION(*)::VX
    INTEGER,DIMENSION(*)::IL,JL
    INTEGER::P,RL
    X=B
    DO RL=1,NRL
       X(RL)=X(RL)/VX(IL(RL))
       T=X(RL)
       DO KL=IL(RL)+1,IL(RL+1)-1
          X(JL(KL))=X(JL(KL))-T*VX(KL)
       END DO
    END DO
  END SUBROUTINE SPARSEDENSELXBCSC

!-------------------------------
!*** CSR SPARSEDENSE UX=B WITH U
!*** BEING UPPER TRIANGULAR
!*** AND SPARSE
!*** DIAGONALS ARE AT IU(RU)
!*** THE BEGGINING OF EACH LINE
!-------------------------------
  SUBROUTINE SPARSEDENSEUXBCSR(NRU,IU,JU,VU,X,B)
    IMPLICIT REAL(8)(A-H,O-Z)
    REAL(8),DIMENSION(NRU)::X,B
    REAL(8),DIMENSION(*)::VU
    INTEGER,DIMENSION(*)::IU,JU
    INTEGER::RU
    X(NRU)=B(NRU)/VU(IU(NRU))
    DO RU=NRU-1,1,-1
       T=B(RU)
       DO KU=IU(RU)+1,IU(RU+1)-1
          T=T-VU(KU)*X(JU(KU))
       END DO
       X(RU)=T/VU(IU(RU))
    END DO
  END SUBROUTINE SPARSEDENSEUXBCSR

!------------------------------
!*** SPARSEDENSE LX=B WITH L
!*** BEING LOWER TRIANGULAR
!*** AND SPARSE
!*** DIAGONALS ARE AT IL(J+1)-1
!*** THE END OF EACH LINE
!------------------------------
  SUBROUTINE SPARSEDENSELXB(NRL,IL,JL,VL,X,B)
    IMPLICIT REAL(8)(A-H,O-Z)
    REAL(8),DIMENSION(NRL)::X,B
    REAL(8),DIMENSION(*)::VL
    INTEGER,DIMENSION(*)::IL,JL
    INTEGER::P
    DO J=1,NRL
       X(J)=B(J)
       DO P=IL(J),IL(J+1)-2
          X(J)=X(J)-VL(P)*X(JL(P))
       END DO
       X(J)=X(J)/VL(IL(J+1)-1)
    END DO
  END SUBROUTINE SPARSEDENSELXB

!----------------------------------------
!*** SPARSEDENSE L^TX=B WITH L
!*** BEING LOWER TRIANGULAR
!*** AND SPARSE
!*** DIAGONALS ARE AT LP(J+1)-1
!*** THE END OF EACH LINE
!*** LX(LP(J+1)-1) ARE L_{JJ}
!----------------------------------------
  SUBROUTINE SPARSEDENSELTXB(NRL,IL,JL,VL,X,B)
    IMPLICIT REAL(8)(A-H,O-Z)
    REAL(8),DIMENSION(NRL)::X,B
    REAL(8),DIMENSION(*)::VL
    INTEGER,DIMENSION(*)::IL,JL
    INTEGER::P
    X=B
    DO I=NRL,1,-1
       X(I)=X(I)/VL(IL(I+1)-1)
       DO P=IL(I),IL(I+1)-2
          X(JL(P))=X(JL(P))-VL(P)*X(I)
       END DO
    END DO
  END SUBROUTINE SPARSEDENSELTXB
  
  SUBROUTINE LDLLSOLVE(N,X,LP,LI,LX)
    IMPLICIT REAL(8)(A-H,O-Z)
    REAL(8),DIMENSION(*)::X,LX
    INTEGER,DIMENSION(*)::LP,LI
    INTEGER::P
    DO J=1,N
       DO P=LP(J),LP(J+1)-1
          X(LI(P))=X(LI(P))-LX(P)*X(J)
       END DO
    END DO
  END SUBROUTINE LDLLSOLVE
  SUBROUTINE LDLDSOLVE(N,X,D)
    REAL(8),DIMENSION(*)::X,D
    DO J=1,N
       X(J)=X(J)/D(J)
    END DO
  END SUBROUTINE LDLDSOLVE
  SUBROUTINE LDLLTSOLVE(N,X,LP,LI,LX)
    IMPLICIT REAL(8)(A-H,O-Z)
    REAL(8),DIMENSION(*)::X,LX
    INTEGER,DIMENSION(*)::LP,LI
    INTEGER::P
    DO J=N,1,-1
       DO P=LP(J),LP(J+1)-1
          X(J)=X(J)-LX(P)*X(LI(P))
       END DO
    END DO
  END SUBROUTINE LDLLTSOLVE
END MODULE SPARSE
!******************************************
!*** THESE ROUTINES CONCERN THE BUCKET SORT
!*** YEY!
!******************************************
!
!*** MODULO POLYGBUCKET
!
MODULE POLYGBUCKET
  USE BASFUN
  USE SPARSE
  SAVE
  PRIVATE
  PUBLIC::NEIG_XP,NEIG_XN,NEIG_NN,NEIG_PP,NEIG_PN,NEIG_NP,CREATEBUCK,BUCKETSS,PRINCOMPAN,WPRINCOMPAN
  TYPE BUCKETSS
     INTEGER,DIMENSION(3)::NBD
     INTEGER,DIMENSION(:),ALLOCATABLE::BN,BP,K1,K2,L1,L2
     INTEGER::NPOIN=0
     INTEGER::NPOLY=0
     INTEGER::NTB=0  
     REAL(8),DIMENSION(3)::XMI,XMA
     REAL(8),DIMENSION(3,3)::VCP
  END TYPE BUCKETSS
CONTAINS
  SUBROUTINE NEIG_XP(BS,X,NN,LN)
    TYPE(BUCKETSS)::BS
    REAL(8),DIMENSION(3)::X,XT
    INTEGER,DIMENSION(:),ALLOCATABLE::LN
    INTEGER,DIMENSION(27)::IVIZ
    DO J=1,3
       XT(J)=DOTPROD(3,BS%VCP(1:3,J),X(1:3))
    END DO
    CALL EXTPES(NVIZ,NBUCK(BS%XMI,BS%XMA,XT,BS%NBD),IVIZ,BS%NBD)
    NN=0
    DO I=1,NVIZ
       IB=IVIZ(I)
       NN=BS%K2(IB+1)-BS%K2(IB)+NN
    END DO
    CALL SALLOC(NN,LN)
    K=0
    DO J=1,NVIZ
       IB=IVIZ(J)
       DO I=BS%K2(IB),BS%K2(IB+1)-1
          K=K+1
          LN(K)=BS%L2(I)
       END DO
    END DO
  END SUBROUTINE NEIG_XP
  SUBROUTINE NEIG_XN(BS,X,NN,LN)
    TYPE(BUCKETSS)::BS
    REAL(8),DIMENSION(3)::X,XT
    INTEGER,DIMENSION(:),ALLOCATABLE::LN
    INTEGER,DIMENSION(27)::IVIZ
    DO J=1,3
       XT(J)=DOTPROD(3,BS%VCP(1:3,J),X(1:3))
    END DO
    CALL EXTPES(NVIZ,NBUCK(BS%XMI,BS%XMA,XT,BS%NBD),IVIZ,BS%NBD)
    NN=0
    DO I=1,NVIZ
       IB=IVIZ(I)
       NN=BS%K1(IB+1)-BS%K1(IB)+NN
    END DO
    CALL SALLOC(NN,LN)
    K=0
    DO J=1,NVIZ
       IB=IVIZ(J)
       DO I=BS%K1(IB),BS%K1(IB+1)-1
          K=K+1
          LN(K)=BS%L1(I)
       END DO
    END DO
  END SUBROUTINE NEIG_XN
  SUBROUTINE NEIG_NN(BS,IN,NN,LN)
    TYPE(BUCKETSS)::BS
    INTEGER,DIMENSION(:),ALLOCATABLE::LN
    INTEGER,DIMENSION(27)::IVIZ
    JB=BS%BN(IN)
    CALL EXTPES(NVIZ,JB,IVIZ,BS%NBD)
    NN=0
    DO I=1,NVIZ
       IB=IVIZ(I)
       NN=BS%K1(IB+1)-BS%K1(IB)+NN
    END DO
    CALL SALLOC(NN,LN)
    K=0
    DO J=1,NVIZ
       IB=IVIZ(J)
       DO I=BS%K1(IB),BS%K1(IB+1)-1
          K=K+1
          LN(K)=BS%L1(I)
       END DO
    END DO
  END SUBROUTINE NEIG_NN
  SUBROUTINE NEIG_PP(BS,IN,NN,LN)
    TYPE(BUCKETSS)::BS
    INTEGER,DIMENSION(:),ALLOCATABLE::LN
    INTEGER,DIMENSION(27)::IVIZ
    JB=BS%BP(IN)
    CALL EXTPES(NVIZ,JB,IVIZ,BS%NBD)
    NN=0
    DO I=1,NVIZ
       IB=IVIZ(I)
       NN=BS%K2(IB+1)-BS%K2(IB)+NN
    END DO
    CALL SALLOC(NN,LN)
    K=0
    DO J=1,NVIZ
       IB=IVIZ(J)
       DO I=BS%K2(IB),BS%K2(IB+1)-1
          K=K+1
          LN(K)=BS%L2(I)
       END DO
    END DO
  END SUBROUTINE NEIG_PP
  SUBROUTINE NEIG_PN(BS,IN,NN,LN)
    TYPE(BUCKETSS)::BS
    INTEGER,DIMENSION(:),ALLOCATABLE::LN
    INTEGER,DIMENSION(27)::IVIZ
    JB=BS%BP(IN)
    CALL EXTPES(NVIZ,JB,IVIZ,BS%NBD)
    NN=0
    DO I=1,NVIZ
       IB=IVIZ(I)
       NN=BS%K1(IB+1)-BS%K1(IB)+NN
    END DO
    CALL SALLOC(NN,LN)
    K=0
    DO J=1,NVIZ
       IB=IVIZ(J)
       DO I=BS%K1(IB),BS%K1(IB+1)-1
          K=K+1
          LN(K)=BS%L1(I)
       END DO
    END DO
  END SUBROUTINE NEIG_PN
  SUBROUTINE NEIG_NP(BS,IN,NN,LN)
    TYPE(BUCKETSS)::BS
    INTEGER,DIMENSION(:),ALLOCATABLE::LN
    INTEGER,DIMENSION(27)::IVIZ
    JB=BS%BN(IN)
    CALL EXTPES(NVIZ,JB,IVIZ,BS%NBD)
    NN=0
    DO I=1,NVIZ
       IB=IVIZ(I)
       NN=BS%K2(IB+1)-BS%K2(IB)+NN
    END DO
    CALL SALLOC(NN,LN)
    K=0
    DO J=1,NVIZ
       IB=IVIZ(J)
       DO I=BS%K2(IB),BS%K2(IB+1)-1
          K=K+1
          LN(K)=BS%L2(I)
       END DO
    END DO
  END SUBROUTINE NEIG_NP
  SUBROUTINE CREATEBUCK(BS,NN,NP,IP,JP,XC)
    IMPLICIT REAL(8) (A-H,O-Z)
    TYPE(BUCKETSS)::BS
    REAL(8),DIMENSION(:,:),ALLOCATABLE::XCOO
    INTEGER,DIMENSION(*)::IP,JP
    REAL(8),DIMENSION(3,*)::XC
    REAL(8),DIMENSION(3)::A,B,ATR,DMM
    BS%NPOIN=NN
    BS%NPOLY=NP
    CALL SALLOC(3,BS%NPOIN,XCOO)
    CALL SALLOC(BS%NPOIN,BS%BN)
    CALL SALLOC(BS%NPOLY,BS%BP)
    CALL PRINCOMPAN(BS%NPOIN,XC,BS%VCP)
    DO I=1,BS%NPOIN
       DO J=1,3
          XCOO(J,I)=DOTPROD(3,BS%VCP(1:3,J),XC(1:3,I))
       END DO
    END DO
    CALL PCONSR(3,DMM,0.0D00)   
    CALL PCONSR(3,BS%XMI,0.0D00)   
    CALL PCONSR(3,BS%XMA,0.0D00)    
    DO I=1,BS%NPOLY
       IST=IP(I)
       IFI=IP(I+1)
       NNP=IFI-IST
       DO K=1,3
          A(K)=-HUGE(1.0D00)
          B(K)=HUGE(1.0D00)
       END DO
       DO J=1,NNP
          IN=JP(J-1+IST)
          DO K=1,3
             A(K)=MAX(A(K),XCOO(K,IN))
             B(K)=MIN(B(K),XCOO(K,IN))
          END DO
       END DO
       DO K=1,3                   
          DMM(K)=MAX(DMM(K),A(K)-B(K))
       END DO
    END DO
    DO I=1,3
       BS%XMI(I)=XINDMIN(NN,XCOO(I,1:NN))
       BS%XMA(I)=XINDMAX(NN,XCOO(I,1:NN))
       ATR(I)=BS%XMA(I)-BS%XMI(I)
    END DO
    CALL DETNBD(ATR,DMM,BS%NBD,BS%NTB)    
    DO I=1,BS%NPOIN
       BS%BN(I)=NBUCK(BS%XMI,BS%XMA,XCOO(1:3,I),BS%NBD)
    END DO
    DO I=1,BS%NPOLY
       J=JP(IP(I))
       BS%BP(I)=NBUCK(BS%XMI,BS%XMA,XCOO(1:3,J),BS%NBD)
    END DO
    CALL SALLOC(BS%NPOIN,BS%L1)
    CALL SALLOC(BS%NPOLY,BS%L2)
    CALL SALLOC(BS%NTB+1,BS%K1)
    CALL SALLOC(BS%NTB+1,BS%K2)
    CALL INVIND_ONE(BS%NPOIN,BS%NTB,BS%K1,BS%BN,BS%L1)
    CALL INVIND_ONE(BS%NPOLY,BS%NTB,BS%K2,BS%BP,BS%L2)
    CALL SALLOC(0,0,XCOO)
  END SUBROUTINE CREATEBUCK
!
!*** PRINCIPAL COMPONENT ANALYSIS-DETERMINATION
!*** OF NEW COORDINATES
!
  SUBROUTINE PRINCOMPAN(N,X,VCP)
    IMPLICIT REAL(8) (A-H,O-Z)
    REAL(8),DIMENSION(3,*)::X
    REAL(8),DIMENSION(3)::TEMP,VLP
    INTEGER,DIMENSION(3)::PER
    REAL(8),DIMENSION(3,3)::VCP
    IF(N.LE.0)RETURN
    RCONST=1.0D00/N
    CALL PCONSR(3,VLP,0.0D00)
    DO I=1,N
       VLP=VLP+X(1:3,I)*RCONST
    END DO
    CALL PCONSR(9,VCP,0.0D00)
    DO I=1,N
       TEMP=X(1:3,I)-VLP
       CALL UPDTENS(3,VCP,TEMP,TEMP)
    END DO
    CALL ESCVEC(9,VCP,RCONST,VCP)
    CALL JACOBIT(VCP,VLP,VCP,3,IERR)
    CALL SORT(3,VLP,PER)
    CALL PERMUT(3,VLP,PER)
    DO I=1,3
       CALL PERMUT(3,VCP(I,1:3),PER)
    END DO
  END SUBROUTINE PRINCOMPAN
!
!*** WEIGHED PRINCIPAL COMPONENT ANALYSIS
!
  SUBROUTINE WPRINCOMPAN(N,W,X,VCP)
    IMPLICIT REAL(8) (A-H,O-Z)
    REAL(8),DIMENSION(3,*)::X
    REAL(8),DIMENSION(*)::W
    INTEGER,DIMENSION(3)::PER
    REAL(8),DIMENSION(3)::TEMP,VLP
    REAL(8),DIMENSION(3,3)::VCP
    IF(N.LE.0)RETURN
    RCONST=1.0D00/SUMLIST(N,W)
    SCONST=1.0D00/N
    CALL PCONSR(3,VLP,0.0D00)
    DO I=1,N
       VLP=VLP+X(1:3,I)*W(I)*RCONST
    END DO
    CALL PCONSR(9,VCP,0.0D00)
    DO I=1,N
       TEMP=X(1:3,I)-VLP
       CALL UPDTENS(3,VCP,TEMP,TEMP)
    END DO
    CALL ESCVEC(9,VCP,SCONST,VCP)
    CALL JACOBIT(VCP,VLP,VCP,3,IERR)
    CALL SORT(3,VLP,PER)
    CALL PERMUT(3,VLP,PER)
    DO I=1,3
       CALL PERMUT(3,VCP(I,1:3),PER)
    END DO
  END SUBROUTINE WPRINCOMPAN
!
!*** DETERMINA A EXTENSO DE BUCKETS
!*** A PESQUISAR A VOLTA DE UM DADO PONTO
!*** IBU{I}:NDICE A PESQUISAR
!*** IVIZ(27){O}:INDICES VIZINHOS E O
!*** NBD(NDI){I}:INDICES NAS NDI DIRECCOES
!*** PRPRIO
  SUBROUTINE EXTPES(NVIZ,INDB,IVIZ,NBD)
    INTEGER,DIMENSION(3)::JNC,IND
    INTEGER,DIMENSION(*)::IVIZ,NBD
    CALL PCONSI(27,IVIZ,0)
    CALL INVBUCKET(INDB,NBD,IND)
    NVIZ=0
    DO I=-1,1
       JNC(1)=IND(1)+I
       IF(JNC(1).GT.NBD(1).OR.JNC(1).LE.0)CYCLE
       DO J=-1,1
          JNC(2)=IND(2)+J
          IF(JNC(2).GT.NBD(2).OR.JNC(2).LE.0)CYCLE
          DO K=-1,1
             JNC(3)=IND(3)+K
             IF(JNC(3).GT.NBD(3).OR.JNC(3).LE.0)CYCLE
             NVIZ=NVIZ+1
             IVIZ(NVIZ)=INDBUCKET(NBD,JNC)
          END DO
       ENDDO
    ENDDO
  END SUBROUTINE EXTPES
!*** DETERMINAO DE UM NDICE
!*** NDI{I}:DIMENSO DO PROBLEMA
!*** NBD(NDI){I}:NMERO DE BUCKETS EM CADA DIRECO
!*** IND(NDI){I}:NDICES NAS NDI DIRECES
  INTEGER FUNCTION INDBUCKET(NBD,IND)
    INTEGER,DIMENSION(*)::IND,NBD
    INDBUCKET=IND(1)+NBD(1)*(IND(2)-1)+NBD(1)*NBD(2)*(IND(3)-1)
  END FUNCTION INDBUCKET
!*** A PARTIR DE UM NDICE, DETERMINA
!*** OS BUCKETS NAS TRS DIRECES
!*** NDI{I}:DIMENSO DO PROBLEMA
!*** INDT{I}:NDICE TOTAL
!*** NBD(NDI){I}:NMERO DE BUCKETS EM CADA DIRECO
!*** IND(NDI){O}:NDICES NAS NDI DIRECES
!*** PROF. TIMON RABZUCK DETECTED A BUG IN PREVIOUS VERSION
!***               NOW IS CORRECTED
  SUBROUTINE INVBUCKET(INDT,NBD,IND)
    INTEGER,DIMENSION(*)::IND,NBD
    NX=NBD(1)
    NY=NBD(2)
    NXY=NX*NY
    IND(3)=INT((INDT-1)/NXY)+1
    JNDT=INDT-(IND(3)-1)*NXY
    IND(2)=INT((JNDT-1)/NX)+1
    IND(1)=MOD(JNDT-1,NX)+1
  END SUBROUTINE INVBUCKET
!*** NMERO DE BUCKET PARA UM CONJUNTO DE COORDENADAS
!*** XMI(NDI){I}:MNIMOS DAS COORDENADAS
!*** XMA(NDI){I}:MXIMOS DAS COORDENADAS
!*** XCU(NDI){I}:COORDENADAS CORRENTES
!*** NBD(NDI){I}:NMERO DE BUCKETS EM CADA DIRECO
  INTEGER FUNCTION NBUCK(XMI,XMA,XCU,NBD)
    IMPLICIT REAL(8) (A-H,O-Z)
    REAL(8),DIMENSION(*)::XMI,XMA,XCU
    INTEGER,DIMENSION(*)::NBD
    INTEGER,DIMENSION(3)::PC
!*** DETERMINA OS CDIGOS DAS DIRECES
    DO I=1,3
       RTEMP=XMA(I)-XMI(I)
       IF(ABS(RTEMP).GT.TINY(RTEMP))THEN
          NN=INT(NBD(I)*(XCU(I)-XMI(I))/(XMA(I)-XMI(I)))+1
       ELSE
          NN=1
       END IF
       NN=MIN(MAX(1,NN),NBD(I))
       PC(I)=NN
    ENDDO
    NBUCK=INDBUCKET(NBD,PC)
  END FUNCTION NBUCK
!
!*** DADO O ATRAVANCAMENTO
!*** E AS DIMENSOES MAXIMAS EM CADA DIRECCAO
!*** DETERMINA O NUMERO DE BUCKETS
!*** EM CADA DIRECCAO
!*** E O NUMERO TOTAL DE BUCKETS
!*** NDI{I}:NUMERO DE DIMENSOES
!*** ATR(NDI){I}:ATRAVANCAMENTOS
!*** DMM(NDI){I}:DIMENSOES MAXIMAS EM CADA DIRECCAO
!*** NBD(NDI){O}:NUMERO DE BUCKETS EM CADA DIRECCAO
!*** NTB(NDI){O}:NUMERO TOTAL DE BUCKETS
!SEEMS OK
  SUBROUTINE DETNBD(ATR,DMM,NBD,NTB)
    IMPLICIT REAL(8) (A-H,O-Z)
!*** NAO VALE A PENA MUDAR NBDM
    INTEGER,PARAMETER::NBDM=1000
    INTEGER,DIMENSION(*)::NBD
    REAL(8),DIMENSION(*)::ATR,DMM
    REAL(8),DIMENSION(3)::DMMC
    IMI=INDMINSS(3,DMM)
    TOL=(1.0D-6*DMM(IMI)+TINY(TOL))
    DO I=1,3
       DMMC(I)=DMM(I)+TOL
    END DO
    DO I=1,3
       NBD(I)=MIN(MAX(1,INT(ATR(I)/DMMC(I))),NBDM)
    END DO
    NTB=INDBUCKET(NBD,NBD)    
  END SUBROUTINE DETNBD
END MODULE POLYGBUCKET
